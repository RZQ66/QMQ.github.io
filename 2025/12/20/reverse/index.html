<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/QMQ.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/QMQ.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/QMQ.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/QMQ.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/QMQ.github.io/css/main.css">


<link rel="stylesheet" href="/QMQ.github.io/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rzq66.github.io","root":"/QMQ.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.QYQSの奇妙冒险ida中的逆向 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879__int64 __fastcall main()&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="geekwp">
<meta property="og:url" content="https://rzq66.github.io/QMQ.github.io/2025/12/20/reverse/index.html">
<meta property="og:site_name" content="QVQ blog">
<meta property="og:description" content="1.QYQSの奇妙冒险ida中的逆向 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879__int64 __fastcall main()&amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/QYQS.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/YYYdaim.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/YYYdai.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/YYYda.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/12.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/13.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/16.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/14.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/15.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/11.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/10.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/8.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/9.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/7.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/6.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/1.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/5.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/3.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/3.png">
<meta property="og:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/2.png">
<meta property="article:published_time" content="2025-12-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-21T13:51:09.416Z">
<meta property="article:author" content="QVQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rzq66.github.io/QMQ.github.io/images/geek/QYQS.png">

<link rel="canonical" href="https://rzq66.github.io/QMQ.github.io/2025/12/20/reverse/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>geekwp | QVQ blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/QMQ.github.io/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/QMQ.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QVQ blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/QMQ.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/QMQ.github.io/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/QMQ.github.io/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/QMQ.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/QMQ.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/QMQ.github.io/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a>

  </li>
        <li class="menu-item menu-item-portfolio">

    <a href="/QMQ.github.io/portfolio/" rel="section"><i class="fa fa-fw fa-briefcase"></i>作品</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rzq66.github.io/QMQ.github.io/2025/12/20/reverse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/QMQ.github.io/images/avatar.gif">
      <meta itemprop="name" content="QVQ">
      <meta itemprop="description" content="睡觉中......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QVQ blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          geekwp
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-12-20T00:00:00+08:00">2025-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-21 21:51:09" itemprop="dateModified" datetime="2025-12-21T21:51:09+08:00">2025-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/QMQ.github.io/categories/wp/" itemprop="url" rel="index"><span itemprop="name">wp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h6 id="1-QYQSの奇妙冒险"><a href="#1-QYQSの奇妙冒险" class="headerlink" title="1.QYQSの奇妙冒险"></a>1.QYQSの奇妙冒险</h6><p>ida中的逆向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main()</span><br><span class="line">&#123;</span><br><span class="line">  char *v0; // rdi</span><br><span class="line">  __int64 j; // rcx</span><br><span class="line">  size_t v3; // rax</span><br><span class="line">  size_t v4; // rax</span><br><span class="line">  char v5; // [rsp+20h] [rbp+0h] BYREF</span><br><span class="line">  char input[76]; // [rsp+28h] [rbp+8h] BYREF</span><br><span class="line">  char key[44]; // [rsp+74h] [rbp+54h] BYREF</span><br><span class="line">  int QYQS[29]; // [rsp+A0h] [rbp+80h]</span><br><span class="line">  int i; // [rsp+114h] [rbp+F4h]</span><br><span class="line">  int k; // [rsp+134h] [rbp+114h]</span><br><span class="line">  size_t v11; // [rsp+208h] [rbp+1E8h]</span><br><span class="line"></span><br><span class="line">  v0 = &amp;v5;</span><br><span class="line">  for ( j = 80LL; j; --j )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v0 = -858993460;</span><br><span class="line">    v0 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  j___CheckForDebuggerJustMyCode(&amp;_F26D15BD_FileName_cpp);</span><br><span class="line">  strcpy(key, &quot;QYQS&quot;);</span><br><span class="line">  QYQS[0] = 2;</span><br><span class="line">  QYQS[1] = 1;</span><br><span class="line">  QYQS[2] = 16;</span><br><span class="line">  QYQS[3] = 43;</span><br><span class="line">  QYQS[4] = 28;</span><br><span class="line">  QYQS[5] = 3;</span><br><span class="line">  QYQS[6] = 23;</span><br><span class="line">  QYQS[7] = 57;</span><br><span class="line">  QYQS[8] = 6;</span><br><span class="line">  QYQS[9] = 1;</span><br><span class="line">  QYQS[10] = 34;</span><br><span class="line">  QYQS[11] = 41;</span><br><span class="line">  QYQS[12] = 14;</span><br><span class="line">  QYQS[13] = 11;</span><br><span class="line">  QYQS[14] = 45;</span><br><span class="line">  QYQS[15] = 109;</span><br><span class="line">  QYQS[16] = 6;</span><br><span class="line">  QYQS[17] = 32;</span><br><span class="line">  QYQS[18] = 23;</span><br><span class="line">  QYQS[19] = 127;</span><br><span class="line">  QYQS[20] = 56;</span><br><span class="line">  Menu();</span><br><span class="line">  j_scanf_s(&quot;%s&quot;, input);</span><br><span class="line">  if ( j_strlen_0(input) == 21 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = i;</span><br><span class="line">      v3 = j_strlen_0(input);</span><br><span class="line">      if ( v11 &gt;= v3 )</span><br><span class="line">        break;</span><br><span class="line">      input[i] ^= i;</span><br><span class="line">      v11 = i;</span><br><span class="line">      input[i] ^= key[i % 4];</span><br><span class="line">    &#125;</span><br><span class="line">    for ( k = 0; ; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = k;</span><br><span class="line">      v4 = j_strlen_0(input);</span><br><span class="line">      if ( v11 &gt;= v4 )</span><br><span class="line">        break;</span><br><span class="line">      if ( input[k] != QYQS[k] )</span><br><span class="line">        goto LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    typeWriterEffect(&amp;byte_14001C468);</span><br><span class="line">    j_printf(&quot;\n&quot;);</span><br><span class="line">    j_printf(asc_14001C478);</span><br><span class="line">    _getch();</span><br><span class="line">    return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_5:</span><br><span class="line">    typeWriterEffect(&amp;byte_14001C448);</span><br><span class="line">    return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正向逻辑：先比较输入flag长度是否为21，然后进入for循环进行两次异或，先与i，再与key数组，最后与比较QSQY数组比较。<br>逆向逻辑：将QYQS数组先与key数组进行异或，再与i<br>解密代码<br><img src="/QMQ.github.io/images/geek/QYQS.png"><br>得到flag：SYC{I_@m_QyqS_r1GhT?}</p>
<h6 id="2-ez-pyyy"><a href="#2-ez-pyyy" class="headerlink" title="2.ez_pyyy"></a>2.ez_pyyy</h6><p>下载附件后发现与常规的附件不相同，是pyc，一开始以为和之前的差不多，但放到ida之后发现只有大块的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">           db 0E3h</span><br><span class="line">seg000:0000000000000011                 align 8</span><br><span class="line">seg000:0000000000000018                 dq 0</span><br><span class="line">seg000:0000000000000020                 dq 400000003600h, 64000001227300h, 464036402640164h, 564036404640164h</span><br><span class="line">seg000:0000000000000040                 dq 664016400640364h, 564036404640564h, 64036405640364h</span><br><span class="line">seg000:0000000000000058                 dq 164016404640164h, 464076403640164h, 164016407640164h</span><br><span class="line">seg000:0000000000000070                 dq 864076404640164h, 364076409640164h, 36405640A640464h</span><br><span class="line">seg000:0000000000000088                 dq 36407640B640564h, 364036405640364h, 165005A36670764h</span><br><span class="line">seg000:00000000000000A0                 dq 0D64029C0C640265h, 265035A04840E64h, 39C0F6402650465h</span><br><span class="line">seg000:00000000000000B8                 dq 55A048411641064h, 29C126404650465h, 65A048414641364h</span><br><span class="line">seg000:00000000000000D0                 dq 1564026504650265h, 48417641664039Ch, 26B18640865075Ah</span><br><span class="line">seg000:00000000000000E8                 dq 95A19641E720190h, 0A5A018309650365h, 2831A640A650565h</span><br><span class="line">seg000:0000000000000100                 dq 1C641B6402650A5Ah, 18300440A650084h, 1D640A650A5A0183h</span><br><span class="line">seg000:0000000000000118                 dq 1903851E641D64h, 1F640A6507650A5Ah, 0BA00A650A5A0283h</span><br><span class="line">seg000:0000000000000130                 dq 190026B006500A1h, 18320640C651672h, 21640C65086E0001h</span><br><span class="line">seg000:0000000000000148                 dq 531D6400010183h, 0E900000030E92229h, 39E900000037h</span><br><span class="line">seg000:0000000000000160                 dq 35E900000032E900h, 34E9000000h, 36E900000065E9h, 0E900000062E90000h</span><br><span class="line">seg000:0000000000000180                 dq 38E900000061h, 22900000063E900h, 74657206DA7301DAh</span><br><span class="line">seg000:0000000000000198                 dq 1636E7275h, 0</span><br><span class="line">seg000:00000000000001A8                 db    1</span><br><span class="line">seg000:00000000000001A9                 align 4</span><br></pre></td></tr></table></figure>
<p>后查完资料发现要将专门软件进行反编译<br>![][geek&#x2F;images&#x2F;YYY.png]<br>获得源代码<br><img src="/QMQ.github.io/images/geek/YYYdaim.png"><br><img src="/QMQ.github.io/images/geek/YYYdai.png"><br>正向逻辑：flag先经过转字节，再进行异或加密，接着进行位操作，倒序，向循环左移32位，得到cipher<br>逆向逻辑：将cipher，循环右移32位，数据正序，逆运算，异或，转成utf-8<br>解密代码<br><img src="/QMQ.github.io/images/geek/YYYda.png"><br>SYC{jtfgdsfda554_a54d8as53}</p>
<h6 id="3-only-flower"><a href="#3-only-flower" class="headerlink" title="3.only_flower"></a>3.only_flower</h6><p>进入ida中发现花指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  __main();</span><br><span class="line">  printf(&quot;Welcome to Flowerdance. Input your flag: &quot;);</span><br><span class="line">  JUMPOUT(0x401620);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入汇编界面，发现jmp指令，其逻辑是跳转到自身逻辑加1的位置，也就是FF。所以将E8nop掉，同时还有text加jnz，也要将其nop掉，最后将所有的花去除得到伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">40161F</span><br><span class="line">.text:0040161F loc_40161F:                             ; CODE XREF: _main:loc_40161F↑j</span><br><span class="line">.text:0040161F                 jmp     short near ptr loc_40161F+1</span><br><span class="line">.text:0040161F _main           endp</span><br><span class="line">.text:0040161F</span><br></pre></td></tr></table></figure>
<p><img src="/QMQ.github.io/images/geek/12.png"><br>伪代码<br><img src="/QMQ.github.io/images/geek/13.png"><br>加密逻辑：先进行异或，左移，与i相加，然后放进缓冲区，与CIPHER比较<br><img src="/QMQ.github.io/images/geek/16.png"><br><img src="/QMQ.github.io/images/geek/14.png"><br><img src="/QMQ.github.io/images/geek/15.png"><br>解密逻辑：现减去i，得rol8结果，接着右移，最后异或<br>解密代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def ror8(n, k):</span><br><span class="line"></span><br><span class="line">    return ((n &gt;&gt; k) | (n &lt;&lt; (8 - k))) &amp; 0xFF</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">cipher = [0x0A, 0x84, 0xC2, 0x84, 0x51, 0x48, 0x5F, 0xF2, 0x9E, 0x8D, 0xD0, 0x84, 0x75, 0x67, 0x73, 0x8F, 0xCA, 0x57, 0xD7, 0xE6, 0x14, 0x6E, 0x77, 0xE2, 0x29, 0xFE, 0xDF, 0xCC]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">KEY = b&quot;GEEK2025&quot;</span><br><span class="line"></span><br><span class="line">v4 = len(KEY)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">plain = []</span><br><span class="line"></span><br><span class="line">for i in range(len(cipher)):</span><br><span class="line"></span><br><span class="line">    tmp = (cipher[i] - i) &amp; 0xFF</span><br><span class="line"></span><br><span class="line">    shift = KEY[i % v4] &amp; 7</span><br><span class="line"></span><br><span class="line">    tmp = ror8(tmp, shift)</span><br><span class="line"></span><br><span class="line">    p = tmp ^ KEY[i % v4]</span><br><span class="line"></span><br><span class="line">    plain.append(p)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">print(bytes(plain))</span><br></pre></td></tr></table></figure>


<p>SYC{asdjjasdhjk12wk12ijkejk}</p>
<h6 id="4-ezSMC"><a href="#4-ezSMC" class="headerlink" title="4.ezSMC"></a>4.ezSMC</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; // rax</span><br><span class="line">  int v4; // eax</span><br><span class="line">  int v6; // eax</span><br><span class="line">  CTX ctx; // [rsp+20h] [rbp-60h] BYREF</span><br><span class="line">  uint8_t key[1]; // [rsp+127h] [rbp+A7h] BYREF</span><br><span class="line">  int binlen; // [rsp+128h] [rbp+A8h] BYREF</span><br><span class="line">  int hexlen; // [rsp+12Ch] [rbp+ACh] BYREF</span><br><span class="line">  char input[1024]; // [rsp+130h] [rbp+B0h] BYREF</span><br><span class="line">  char *en3; // [rsp+530h] [rbp+4B0h]</span><br><span class="line">  char *en2; // [rsp+538h] [rbp+4B8h]</span><br><span class="line">  char *en1; // [rsp+540h] [rbp+4C0h]</span><br><span class="line">  uint8_t *bin; // [rsp+548h] [rbp+4C8h]</span><br><span class="line">  uint8_t *hex_ascii; // [rsp+550h] [rbp+4D0h]</span><br><span class="line">  const char *cipher; // [rsp+558h] [rbp+4D8h]</span><br><span class="line"></span><br><span class="line">  _main(argc, argv, envp);</span><br><span class="line">  cipher = &quot;tHMoSoMX71sm62ARQ8aHF6i88nhkH9Ac2J7CrkQsQgXpiy6efoC8YVkzZu1tMyFxCLbbqvgXZHxtwK5TACVhPi1EE5mK6JG56wPNR4d2GmkELGfJHgtcAEH7&quot;;</span><br><span class="line">  printf(&quot;Plz input your flag miao: &quot;);</span><br><span class="line">  v3 = __acrt_iob_func(0);</span><br><span class="line">  fgets(input, 1024, v3);</span><br><span class="line">  input[strcspn(input, &quot;\r\n&quot;)] = 0;</span><br><span class="line">  hex_ascii = ascii_to_hexbytes(input, &amp;hexlen);</span><br><span class="line">  bin = hexstr_to_bytes((const char *)hex_ascii, &amp;binlen);</span><br><span class="line">  key[0] = 17;</span><br><span class="line">  init(&amp;ctx, key, 1);</span><br><span class="line">  encode(&amp;ctx, bin, binlen);</span><br><span class="line">  en1 = bytes_to_hexstr(bin, binlen);</span><br><span class="line">  miao_encrypt();</span><br><span class="line">  v4 = strlen(en1);</span><br><span class="line">  en2 = encodee((const uint8_t *)en1, v4);</span><br><span class="line">  if ( en2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = strlen(en2);</span><br><span class="line">    en3 = enc0de((const uint8_t *)en2, v6);</span><br><span class="line">    if ( !strcmp(en3, cipher) )</span><br><span class="line">      puts(&quot;Correct!&quot;);</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;Wrong!&quot;);</span><br><span class="line">    free(hex_ascii);</span><br><span class="line">    free(bin);</span><br><span class="line">    free(en1);</span><br><span class="line">    free(en2);</span><br><span class="line">    free(en3);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;encodee returned NULL&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag先进入ascii_to_hexbytes函数如图，它是将ascii转成十六进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint8_t *__cdecl ascii_to_hexbytes(const char *s, int *outlen)</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t *buf; // [rsp+20h] [rbp-10h]</span><br><span class="line">  int len; // [rsp+28h] [rbp-8h]</span><br><span class="line">  int i; // [rsp+2Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  len = strlen(s);</span><br><span class="line">  buf = (uint8_t *)malloc(2 * len + 1);</span><br><span class="line">  for ( i = 0; i &lt; len; ++i )</span><br><span class="line">    sprintf((char *const)&amp;buf[2 * i], &quot;%02X&quot;, (unsigned __int8)s[i]);</span><br><span class="line">  *outlen = 2 * len;</span><br><span class="line">  buf[*outlen] = 0;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着又进入hexstr_to_bytes中，将十六进制转成字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uint8_t *__cdecl hexstr_to_bytes(const char *hex, int *outlen)</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t v2; // al</span><br><span class="line">  char tmp[3]; // [rsp+2Dh] [rbp-13h] BYREF</span><br><span class="line">  uint8_t *buf; // [rsp+30h] [rbp-10h]</span><br><span class="line">  int len; // [rsp+38h] [rbp-8h]</span><br><span class="line">  int i; // [rsp+3Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  len = strlen(hex);</span><br><span class="line">  *outlen = len / 2;</span><br><span class="line">  buf = (uint8_t *)malloc(*outlen);</span><br><span class="line">  for ( i = 0; i &lt; *outlen; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(tmp, 0, sizeof(tmp));</span><br><span class="line">    tmp[0] = hex[2 * i];</span><br><span class="line">    tmp[1] = hex[2 * i + 1];</span><br><span class="line">    v2 = strtol(tmp, 0LL, 16);</span><br><span class="line">    buf[i] = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着进入encode函数，通过getbyte的核心逻辑与RC4的伪随机算法相似判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl encode(CTX *ctx, uint8_t *data, int len)</span><br><span class="line">&#123;</span><br><span class="line">  int n; // [rsp+2Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  for ( n = 0; n &lt; len; ++n )</span><br><span class="line">    data[n] ^= getbyte(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint8_t __cdecl getbyte(CTX *ctx)</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t t; // [rsp+Fh] [rbp-1h]</span><br><span class="line"></span><br><span class="line">  ctx-&gt;j += ctx-&gt;S[++ctx-&gt;i];</span><br><span class="line">  t = ctx-&gt;S[ctx-&gt;i];</span><br><span class="line">  ctx-&gt;S[ctx-&gt;i] = ctx-&gt;S[ctx-&gt;j];</span><br><span class="line">  ctx-&gt;S[ctx-&gt;j] = t;</span><br><span class="line">  return ctx-&gt;S[(unsigned __int8)(ctx-&gt;S[ctx-&gt;i] + ctx-&gt;S[ctx-&gt;j])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入bytes_to_hexstr函数中，将字节转化成十六进制的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *__cdecl bytes_to_hexstr(const uint8_t *buf, int len)</span><br><span class="line">&#123;</span><br><span class="line">  char *s; // [rsp+20h] [rbp-10h]</span><br><span class="line">  int i; // [rsp+2Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  s = (char *)malloc(2 * len + 1);</span><br><span class="line">  for ( i = 0; i &lt; len; ++i )</span><br><span class="line">    sprintf(&amp;s[2 * i], &quot;%02x&quot;, buf[i]);</span><br><span class="line">  s[2 * len] = 0;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着进入encodee，发现花指令，结合题目给的信息，猜测是smc造成(在程序运行时修改自身指令的技术)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *__cdecl encodee(const uint8_t *buf, int len)</span><br><span class="line">&#123;</span><br><span class="line">  char v2; // al</span><br><span class="line">  __int64 v3; // rsi</span><br><span class="line"></span><br><span class="line">  *(_BYTE *)(v3 + 27) = v2;</span><br><span class="line">  JUMPOUT(0x4A2012LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时再结合miao_encrypt中的VirtualProtect,最终确定是smc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool __cdecl miao_encrypt()</span><br><span class="line">&#123;</span><br><span class="line">  SIZE_T v1; // rsi</span><br><span class="line">  uint8_t *v2; // rbx</span><br><span class="line">  HANDLE CurrentProcess; // rax</span><br><span class="line">  DWORD old; // [rsp+2Ch] [rbp-14h] BYREF</span><br><span class="line">  SIZE_T sz; // [rsp+30h] [rbp-10h] BYREF</span><br><span class="line">  uint8_t *va; // [rsp+38h] [rbp-8h] BYREF</span><br><span class="line"></span><br><span class="line">  if ( g_miao_encrypted )</span><br><span class="line">    return 1;</span><br><span class="line">  if ( !find_miao_section(&amp;va, &amp;sz) )</span><br><span class="line">    return 0;</span><br><span class="line">  if ( !VirtualProtect(va, sz, 0x40u, &amp;old) )</span><br><span class="line">    return 0;</span><br><span class="line">  miao_xor(va, sz);</span><br><span class="line">  v1 = sz;</span><br><span class="line">  v2 = va;</span><br><span class="line">  CurrentProcess = GetCurrentProcess();</span><br><span class="line">  FlushInstructionCache(CurrentProcess, v2, v1);</span><br><span class="line">  VirtualProtect(va, sz, old, &amp;old);</span><br><span class="line">  g_miao_encrypted = 1;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>smc的去除，参考视频<a href=""><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kMHKzoE6u/?spm_id_from=333.337.search-card.all.click&vd_source=dddf5c077bddc2e3eb8b5006522fa98a">NSSCTF2025 SMC 自修改代码_哔哩哔哩_bilibili</a></a><br>首先在encodee处下断点，然后进入动调，找到下面的画面，然后将这一块圈住先按u，再按c强制转为代码，最后在开头按p，就可以了<br>![[18891fc1-2b0c-4b85-a205-3a3200907420.png]]<br>弄出来如下<br>![[3ced1215-d4b4-406f-9eb4-27edca2466e9.png]]<br>这个可以看出来使用了base64加密<br>最后点进enc0de中，发现使用base58加密</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">char *__cdecl enc0de(const uint8_t *data, int len)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // eax</span><br><span class="line">  int v3; // eax</span><br><span class="line">  char *out; // [rsp+28h] [rbp-38h]</span><br><span class="line">  int *digits; // [rsp+38h] [rbp-28h]</span><br><span class="line">  int size; // [rsp+40h] [rbp-20h]</span><br><span class="line">  int k; // [rsp+44h] [rbp-1Ch]</span><br><span class="line">  int p; // [rsp+48h] [rbp-18h]</span><br><span class="line">  int i; // [rsp+4Ch] [rbp-14h]</span><br><span class="line">  int j; // [rsp+50h] [rbp-10h]</span><br><span class="line">  int carry; // [rsp+54h] [rbp-Ch]</span><br><span class="line">  int carrya; // [rsp+54h] [rbp-Ch]</span><br><span class="line">  int i_0; // [rsp+58h] [rbp-8h]</span><br><span class="line">  int zeros; // [rsp+5Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  size = 138 * len / 100 + 2;</span><br><span class="line">  digits = (int *)calloc(size, 4uLL);</span><br><span class="line">  for ( zeros = 0; zeros &lt; len &amp;&amp; !data[zeros]; ++zeros )</span><br><span class="line">    ;</span><br><span class="line">  for ( i_0 = zeros; i_0 &lt; len; ++i_0 )</span><br><span class="line">  &#123;</span><br><span class="line">    carry = data[i_0];</span><br><span class="line">    for ( j = size - 1; j &gt;= 0; --j )</span><br><span class="line">    &#123;</span><br><span class="line">      carrya = (digits[j] &lt;&lt; 8) + carry;</span><br><span class="line">      digits[j] = carrya % 58;</span><br><span class="line">      carry = carrya / 58;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for ( i = 0; i &lt; size &amp;&amp; !digits[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  out = (char *)malloc(zeros + size - i + 1);</span><br><span class="line">  p = 0;</span><br><span class="line">  for ( k = 0; k &lt; zeros; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = p++;</span><br><span class="line">    out[v2] = 65;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( i &lt; size )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = p++;</span><br><span class="line">    out[v3] = base58_table[digits[i++]];</span><br><span class="line">  &#125;</span><br><span class="line">  out[p] = 0;</span><br><span class="line">  free(digits);</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再结合string判断base64是标准的，base58是不标准的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> _ZZ7encodeePKhiE12base64_table db &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;,0</span><br><span class="line">.rdata:00000000004A6061                 align 20h</span><br><span class="line">.rdata:00000000004A6080 ; const char base58_table[59]</span><br><span class="line">.rdata:00000000004A6080 _ZL12base58_table db &#x27;ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789&#x27;,0</span><br><span class="line">.rdata:00000000004A6080                                         ; DATA XREF: enc0de(uchar const*,int)+1F4↑o</span><br><span class="line">.rdata:00000000004A60BB                 align 20h</span><br></pre></td></tr></table></figure>

<p>整理一下逻辑：flag进行转换，RC4加密，转换，base64加密，base58加密，最后与cipher比较。</p>
<p>解密：现在cyberchef中进行base解密，再用脚本解密<br><img src="/QMQ.github.io/images/geek/11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">def rc4_decrypt(data, key_byte):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;RC4解密&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    key = bytes([key_byte])</span><br><span class="line"></span><br><span class="line">    S = list(range(256))</span><br><span class="line"></span><br><span class="line">    j = 0</span><br><span class="line"></span><br><span class="line">    for i in range(256):</span><br><span class="line"></span><br><span class="line">        j = (j + S[i] + key[i % len(key)]) % 256</span><br><span class="line"></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    i = j = 0</span><br><span class="line"></span><br><span class="line">    result = bytearray()</span><br><span class="line"></span><br><span class="line">    for byte in data:</span><br><span class="line"></span><br><span class="line">        i = (i + 1) % 256</span><br><span class="line"></span><br><span class="line">        j = (j + S[i]) % 256</span><br><span class="line"></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line">        result.append(byte ^ S[(S[i] + S[j]) % 256])</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    return bytes(result)</span><br><span class="line"></span><br><span class="line">def decrypt_from_hex():</span><br><span class="line"></span><br><span class="line">    hex_data = &quot;dfd24c6c33beee2b49329e61186012b05da1542dd3f09fb0e9aed330c87477cc&quot;</span><br><span class="line"></span><br><span class="line">    rc4_key = 17</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    # 1. Hex字符串转字节</span><br><span class="line"></span><br><span class="line">    encrypted_data = bytes.fromhex(hex_data)</span><br><span class="line"></span><br><span class="line">    # 2. RC4解密</span><br><span class="line"></span><br><span class="line">    rc4_decrypted = rc4_decrypt(encrypted_data, rc4_key)</span><br><span class="line"></span><br><span class="line">    # 3. 直接解码为字符串</span><br><span class="line"></span><br><span class="line">    flag = rc4_decrypted.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">    print(f&quot;&#123;flag&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    return flag</span><br><span class="line"></span><br><span class="line"># 运行解密</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    result = decrypt_from_hex()</span><br></pre></td></tr></table></figure>
<p>SYC{OHhhhhhhh_y0u_Kn0m_SMCCCC@!}</p>
<h6 id="5-encode"><a href="#5-encode" class="headerlink" title="5.encode"></a>5.encode</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [xsp+0h] [xbp-220h]</span><br><span class="line">  char v5[256]; // [xsp+8h] [xbp-218h] BYREF</span><br><span class="line">  char v6[256]; // [xsp+108h] [xbp-118h] BYREF</span><br><span class="line"></span><br><span class="line">  puts(&quot;please input: &quot;);</span><br><span class="line">  scanf(v6, 256LL);</span><br><span class="line">  for ( i = 0; i &lt; encrypted_len; ++i )</span><br><span class="line">    v5[i] = v6[i] ^ 0x5A;</span><br><span class="line">  compare(v5, (unsigned int)encrypted_len);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall compare(__int64 a1, unsigned int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [xsp+Ch] [xbp-204h]</span><br><span class="line">  int v4; // [xsp+10h] [xbp-200h]</span><br><span class="line">  _BYTE v7[400]; // [xsp+28h] [xbp-1E8h] BYREF</span><br><span class="line">  _BYTE __dst[64]; // [xsp+1B8h] [xbp-58h] BYREF</span><br><span class="line"></span><br><span class="line">  memcpy(__dst, &amp;unk_100003EF1, sizeof(__dst));</span><br><span class="line">  v4 = 1;</span><br><span class="line">  if ( (unsigned int)base64_encode(a1, a2, v7) == 64 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt; 64; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v7[i] != __dst[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = 0;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v4 )</span><br><span class="line">    return puts(&quot;Congratulations!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    return puts(&quot;Incorrect answer, please try again.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本只认为是异或Z加上base64加密，但是这样得不出flag，后面我点进scanf中发现它是自定义函数，差点被迷惑住。<br>点开scanf,先进行读取字符，调用enc进行加密，先进行字节填充，将其填充为八的整数，在进行enc_block函数加密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall enc_block(__int64 result, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [xsp+4h] [xbp-3Ch]</span><br><span class="line">  int j; // [xsp+4h] [xbp-3Ch]</span><br><span class="line">  unsigned int v4; // [xsp+8h] [xbp-38h]</span><br><span class="line">  unsigned int v5; // [xsp+10h] [xbp-30h]</span><br><span class="line">  unsigned int v6; // [xsp+14h] [xbp-2Ch]</span><br><span class="line">  _DWORD v7[4]; // [xsp+28h] [xbp-18h]</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  v6 = _byteswap_ulong(*(_DWORD *)result);</span><br><span class="line">  v5 = _byteswap_ulong(*(_DWORD *)(result + 4));</span><br><span class="line">  for ( i = 0; i &lt; 4; ++i )</span><br><span class="line">    v7[i] = (*(unsigned __int8 *)(a2 + 4 * i + 1) &lt;&lt; 16) | (*(unsigned __int8 *)(a2 + 4 * i) &lt;&lt; 24) | (*(unsigned __int8 *)(a2 + 4 * i + 2) &lt;&lt; 8) | *(unsigned __int8 *)(a2 + 4 * i + 3);</span><br><span class="line">  for ( j = 0; j &lt; 32; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (v4 + v7[v4 &amp; 3]);</span><br><span class="line">    v4 -= 1640531527;</span><br><span class="line">    v5 += (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6) ^ (v4 + v7[(v4 &gt;&gt; 11) &amp; 3]);</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)result = HIBYTE(v6);</span><br><span class="line">  *(_BYTE *)(result + 1) = BYTE2(v6);</span><br><span class="line">  *(_BYTE *)(result + 2) = BYTE1(v6);</span><br><span class="line">  *(_BYTE *)(result + 3) = v6;</span><br><span class="line">  *(_BYTE *)(result + 4) = HIBYTE(v5);</span><br><span class="line">  *(_BYTE *)(result + 5) = BYTE2(v5);</span><br><span class="line">  *(_BYTE *)(result + 6) = BYTE1(v5);</span><br><span class="line">  *(_BYTE *)(result + 7) = v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据enc_block处理8位字节，进行32位轮运算，还有固定常量0x9E779B9，判断为XTEA加密，其中密钥为a:geek2025reverse!<br>逆向逻辑：先进行base64解密，接着跟Z异或，再进行XTEA解密，然后处理掉填充的字节<br>解密代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">def xtea_decrypt_block(block, key):</span><br><span class="line"></span><br><span class="line">    v5 = struct.unpack(&#x27;&gt;I&#x27;, block[0:4])[0]</span><br><span class="line"></span><br><span class="line">    v6 = struct.unpack(&#x27;&gt;I&#x27;, block[4:8])[0]</span><br><span class="line"></span><br><span class="line">    k = [struct.unpack(&#x27;&gt;I&#x27;, key[i * 4:(i + 1) * 4])[0] for i in range(4)]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    delta = 0x9E3779B9</span><br><span class="line"></span><br><span class="line">    sum_val = delta * 32</span><br><span class="line"></span><br><span class="line">    mask = 0xFFFFFFFF</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    for _ in range(32):</span><br><span class="line"></span><br><span class="line">        v6 = (v6 - ((((v5 &lt;&lt; 4) ^ (v5 &gt;&gt; 5)) + v5) ^ (sum_val + k[(sum_val &gt;&gt; 11) &amp; 3]))) &amp; mask</span><br><span class="line"></span><br><span class="line">        sum_val = (sum_val - delta) &amp; mask</span><br><span class="line"></span><br><span class="line">        v5 = (v5 - ((((v6 &lt;&lt; 4) ^ (v6 &gt;&gt; 5)) + v6) ^ (sum_val + k[sum_val &amp; 3]))) &amp; mask</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    return struct.pack(&#x27;&gt;I&#x27;, v5) + struct.pack(&#x27;&gt;I&#x27;, v6)</span><br><span class="line"></span><br><span class="line">def xtea_decrypt(data, key):</span><br><span class="line"></span><br><span class="line">    result = b&quot;&quot;</span><br><span class="line"></span><br><span class="line">    for i in range(0, len(data), 8):</span><br><span class="line"></span><br><span class="line">        block = data[i:i + 8]</span><br><span class="line"></span><br><span class="line">        if len(block) &lt; 8:</span><br><span class="line"></span><br><span class="line">            block = block.ljust(8, b&#x27;\x00&#x27;)</span><br><span class="line"></span><br><span class="line">        decrypted_block = xtea_decrypt_block(block, key)</span><br><span class="line"></span><br><span class="line">        result += decrypted_block</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def remove_pkcs7_padding(data):</span><br><span class="line"></span><br><span class="line">    if not data:</span><br><span class="line"></span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">    pad_len = data[-1]</span><br><span class="line"></span><br><span class="line">    if pad_len &gt; 0 and pad_len &lt;= len(data):</span><br><span class="line"></span><br><span class="line">        if all(b == pad_len for b in data[-pad_len:]):</span><br><span class="line"></span><br><span class="line">            return data[:-pad_len]</span><br><span class="line"></span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">hardcoded_b64 = &quot;vBzX30Koxl3HpDaYaFJKhyB/1ckuVCnc4wZhrwUWeNuZkAxr+Qn5UaYbpvymmCrk&quot;</span><br><span class="line"></span><br><span class="line">key = b&quot;geek2025reverse!&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">after_xor = base64.b64decode(hardcoded_b64)</span><br><span class="line"></span><br><span class="line">xtea_encrypted = bytes([b ^ ord(&#x27;Z&#x27;) for b in after_xor])</span><br><span class="line"></span><br><span class="line">padded_plaintext = xtea_decrypt(xtea_encrypted, key)</span><br><span class="line"></span><br><span class="line">original_input = remove_pkcs7_padding(padded_plaintext)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">print(original_input.decode(&#x27;ascii&#x27;))</span><br></pre></td></tr></table></figure>
<p>SYC{St4nd4rd_Funct10n_N0t_4lw4ys_St4nd4rd</p>
<h6 id="6-Gensh1n"><a href="#6-Gensh1n" class="headerlink" title="6.Gensh1n"></a>6.Gensh1n</h6><p>一开始进入main函数，发现只是将arr数组中的数据进行比较v7数组的数据<br>没任何特别的改变，这说明不是关键函数。之后我无意间点进cleanup，发现这个是重要函数，通过字符串great。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 cleanup()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+8h] [rbp-238h]</span><br><span class="line">  int i; // [rsp+Ch] [rbp-234h]</span><br><span class="line">  int v3; // [rsp+10h] [rbp-230h]</span><br><span class="line">  int j; // [rsp+14h] [rbp-22Ch]</span><br><span class="line">  int v5; // [rsp+20h] [rbp-220h]</span><br><span class="line">  int v6; // [rsp+24h] [rbp-21Ch]</span><br><span class="line">  char v7[8]; // [rsp+28h] [rbp-218h] BYREF</span><br><span class="line">  char s[256]; // [rsp+30h] [rbp-210h] BYREF</span><br><span class="line">  char dest[264]; // [rsp+130h] [rbp-110h] BYREF</span><br><span class="line">  unsigned __int64 v10; // [rsp+238h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(0x28u);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  if ( !fgets(s, 256, stdin) )</span><br><span class="line">    exit(1);</span><br><span class="line">  v1 = strlen(s);</span><br><span class="line">  if ( v1 &gt; 0 &amp;&amp; s[v1 - 1] == 10 )</span><br><span class="line">    s[--v1] = 0;</span><br><span class="line">  if ( !(unsigned int)validate_input_length((unsigned int)v1) )</span><br><span class="line">    exit(1);</span><br><span class="line">  for ( i = 0; i &lt;= 7; ++i )</span><br><span class="line">    v7[i] = global_nodes[16 * i];</span><br><span class="line">  if ( !(unsigned int)validate_key(v7, 8LL) )</span><br><span class="line">    exit(1);</span><br><span class="line">  strncpy(dest, s, v1);</span><br><span class="line">  dest[v1] = 0;</span><br><span class="line">  compute_checksum(dest, (unsigned int)v1);</span><br><span class="line">  stack_push(dest);</span><br><span class="line">  stack_push(v1);</span><br><span class="line">  stack_push(v7);</span><br><span class="line">  stack_push(8LL);</span><br><span class="line">  stack_push(sub_44656);</span><br><span class="line">  stack_push(0LL);</span><br><span class="line">  stack_push(4LL);</span><br><span class="line">  reverse_call();</span><br><span class="line">  if ( v1 != 28 )</span><br><span class="line">    exit(1);</span><br><span class="line">  v3 = 1;</span><br><span class="line">  for ( j = 0; j &lt; 28; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( dest[j] != result[j] )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = 0;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = calculate_crc32(dest, 28LL);</span><br><span class="line">  v6 = calculate_crc32(result, 28LL);</span><br><span class="line">  if ( !v3 || v5 != v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    secure_memset(dest, 0LL, 256LL);</span><br><span class="line">    secure_memset(v7, 0LL, 8LL);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Great!&quot;);</span><br><span class="line">  secure_memset(dest, 0LL, 256LL);</span><br><span class="line">  secure_memset(v7, 0LL, 8LL);</span><br><span class="line">  return v10 - __readfsqword(0x28u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正向逻辑：首先读取输入的数据存到s中，v1为其长度，接着v7中存入global_nodes的数据，然后将s中的数据压入dest中，进入sub_44656中进行加密。然后比较与result中的数据<br>根据代码，其中加密为rc4加密</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_44656(__int64 a1, int a2, __int64 a3, int a4)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [rsp+20h] [rbp-220h]</span><br><span class="line">  int j; // [rsp+20h] [rbp-220h]</span><br><span class="line">  int v7; // [rsp+20h] [rbp-220h]</span><br><span class="line">  int v8; // [rsp+24h] [rbp-21Ch]</span><br><span class="line">  int v9; // [rsp+24h] [rbp-21Ch]</span><br><span class="line">  int k; // [rsp+28h] [rbp-218h]</span><br><span class="line">  char v11; // [rsp+2Ch] [rbp-214h]</span><br><span class="line">  char v12; // [rsp+2Ch] [rbp-214h]</span><br><span class="line">  _BYTE v13[520]; // [rsp+30h] [rbp-210h]</span><br><span class="line">  unsigned __int64 v14; // [rsp+238h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v14 = __readfsqword(0x28u);</span><br><span class="line">  v8 = 0;</span><br><span class="line">  for ( i = 0; i &lt;= 255; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v13[i] = i;</span><br><span class="line">    v13[i + 256] = *(_BYTE *)(i % a4 + a3);</span><br><span class="line">  &#125;</span><br><span class="line">  for ( j = 0; j &lt;= 255; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = ((unsigned __int8)v13[j + 256] + v8 + (unsigned __int8)v13[j]) % 256;</span><br><span class="line">    v11 = v13[j];</span><br><span class="line">    v13[j] = v13[v8];</span><br><span class="line">    v13[v8] = v11;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = 0;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  for ( k = 0; k &lt; a2; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = (v7 + 1) % 256;</span><br><span class="line">    v9 = (v9 + (unsigned __int8)v13[v7]) % 256;</span><br><span class="line">    v12 = v13[v7];</span><br><span class="line">    v13[v7] = v13[v9];</span><br><span class="line">    v13[v9] = v12;</span><br><span class="line">    *(_BYTE *)(k + a1) ^= v13[(unsigned __int8)(v13[v7] + v13[v9])];</span><br><span class="line">  &#125;</span><br><span class="line">  return v14 - __readfsqword(0x28u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向逻辑：将result再进行rc4加密即可<br>解密代码（用的ai）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">typedef unsigned char _BYTE;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">unsigned __int64 rc4_decrypt(__int64 data, int data_len, __int64 key, int key_len)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    int v8, v9, v7;</span><br><span class="line"></span><br><span class="line">    char v11, v12;</span><br><span class="line"></span><br><span class="line">    char s_box[520];</span><br><span class="line"></span><br><span class="line">    unsigned __int64 v14;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    v8 = 0;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt;= 255; ++i)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        s_box[i] = i;</span><br><span class="line"></span><br><span class="line">        s_box[i + 256] = *(_BYTE *)(i % key_len + key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (j = 0; j &lt;= 255; ++j)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        v8 = ((unsigned __int8)s_box[j + 256] + v8 + (unsigned __int8)s_box[j]) % 256;</span><br><span class="line"></span><br><span class="line">        v11 = s_box[j];</span><br><span class="line"></span><br><span class="line">        s_box[j] = s_box[v8];</span><br><span class="line"></span><br><span class="line">        s_box[v8] = v11;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v9 = 0;</span><br><span class="line"></span><br><span class="line">    v7 = 0;</span><br><span class="line"></span><br><span class="line">    for (k = 0; k &lt; data_len; ++k)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        v7 = (v7 + 1) % 256;</span><br><span class="line"></span><br><span class="line">        v9 = (v9 + (unsigned __int8)s_box[v7]) % 256;</span><br><span class="line"></span><br><span class="line">        v12 = s_box[v7];</span><br><span class="line"></span><br><span class="line">        s_box[v7] = s_box[v9];</span><br><span class="line"></span><br><span class="line">        s_box[v9] = v12;</span><br><span class="line"></span><br><span class="line">        *(_BYTE *)(k + data) ^= s_box[(unsigned __int8)(s_box[v7] + s_box[v9])];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    unsigned char encrypted_data[] = &#123;0x52, 0x59, 0xF3, 0x8A, 0x00, 0x0F, 0xE6, 0x56, 0x36, 0xE5, 0xF0, 0x33, 0x40, 0x6E, 0x56, 0x81, 0x5A, 0xE5, 0x6F, 0x87, 0x6F, 0x9F, 0x21, 0xC9, 0xA6, 0xBB, 0x16, 0x51&#125;;</span><br><span class="line"></span><br><span class="line">    int data_len = sizeof(encrypted_data);</span><br><span class="line"></span><br><span class="line">    char key[] = &quot;geek2025&quot;;</span><br><span class="line"></span><br><span class="line">    int key_len = strlen(key);</span><br><span class="line"></span><br><span class="line">    rc4_decrypt((__int64)encrypted_data, data_len, (__int64)key, key_len);</span><br><span class="line"></span><br><span class="line">    printf(&quot;解密结果: &quot;);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; data_len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%c&quot;, encrypted_data[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SYC{50_y0u_pl@y_Gensh1n_too}</p>
<h6 id="7-ez-rust"><a href="#7-ez-rust" class="headerlink" title="7.ez_rust"></a>7.ez_rust</h6><p>点进ida中发现一大坨代码，有点不想看，然后点进string</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.rdata:000000014001E77B	0000000B	C	src/main.rs</span><br><span class="line">.rdata:000000014001E7A0	00000056	C	!\&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu</span><br><span class="line">.rdata:000000014001E82B	00000040	C	ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><br><span class="line">.rdata:000000014001E89A	0000000B	C	?456789:;&lt;=</span><br><span class="line">.rdata:000000014001E8B3	00000005	C	\a\b\t\n\v</span><br><span class="line">.rdata:000000014001E8D2	00000014	C	 !\&quot;#$%&amp;&#x27;()*+,-./0123</span><br><span class="line">.rdata:000000014001E96B	0000003C	C	&lt;AA;XAM?,_@;T[r@7E779h8;s&gt;&#x27;`pt=&gt;3c6ASuHFASOtP&lt;Gkf_A4&amp;gPAl1]S</span><br><span class="line">.rdata:000000014001E9A7	00000126	C	███████ ███████ ██████  ██    ██ ██████  ████████      ██████ ██   ██  █████  ██      ██      ███████ ███    ██  ██████  ███████ \n</span><br><span class="line">.rdata:000000014001EAE0	000000D8	C	██         ███  ██   ██ ██    ██      ██    ██        ██      ██   ██ ██   ██ ██      ██      ██      ████   ██ ██       ██      \n</span><br><span class="line">.rdata:000000014001EBC8	00000106	C	█████     ███   ██████  ██    ██  █████     ██        ██      ███████ ███████ ██      ██      █████   ██ ██  ██ ██   ███ █████   \n</span><br><span class="line">.rdata:000000014001ECE0	000000DC	C	██       ███    ██   ██ ██    ██      ██    ██        ██      ██   ██ ██   ██ ██      ██      ██      ██  ██ ██ ██    ██ ██      \n</span><br><span class="line">.rdata:000000014001EDD0	0000012E	C	███████ ███████ ██   ██  ██████  ██████     ██         ██████ ██   ██ ██   ██ ███████ ███████ ███████ ██   ████  ██████  ███████ \n</span><br><span class="line">.rdata:000000014001EF10	00000033	C	Welcome to the Rust Reverse Engineering Challenge!\n</span><br><span class="line">.rdata:000000014001EF58	00000024	C	Find the correct flag to proceed...\n</span><br><span class="line">.rdata:000000014001EFA8	00000011	C	Enter your flag: </span><br><span class="line">.rdata:000000014001EFE8	00000013	C	Failed to read line</span><br><span class="line">.rdata:000000014001F018	0000001B	C	❌ Wrong flag! Try again.\n</span><br><span class="line">.rdata:000000014001F048	00000032	C	🎉 Congratulations! You found the correct flag!\n</span><br><span class="line">	.rdata:000000014001F090	00000007	C	Flag: </span><br></pre></td></tr></table></figure>
<p>就可以看到base64的字符集，如果熟悉base85加密，就可以看出来还使用了base85加密，但是因为我不熟，没看出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, [rbp+0D0h+var_E0]</span><br><span class="line">mov     rdx, [rbp+0D0h+var_D8]</span><br><span class="line">call    _ZN4core3str21_$LT$impl$u20$str$GT$12trim_matches17h6383b3823ce0a622E ; core::str::&lt;impl str&gt;::trim_matches</span><br><span class="line">mov     r9, rdx</span><br><span class="line">mov     [rbp+0D0h+var_128], rax</span><br><span class="line">mov     [rbp+0D0h+var_120], rdx</span><br><span class="line">lea     rdx, unk_14001E828</span><br><span class="line">lea     rcx, [rbp+0D0h+var_A8]</span><br><span class="line">mov     r8, rax</span><br><span class="line">call    _ZN6base646engine6Engine6encode5inner17h9863671b3f4049e6E ; base64::engine::Engine::encode::inner</span><br><span class="line">mov     rax, qword ptr [rbp+0D0h+var_A8+8]</span><br><span class="line">mov     [rbp+0D0h+var_B8], rax</span><br><span class="line">mov     r11, qword ptr [rbp+0D0h+var_98]</span><br><span class="line">mov     qword ptr [rbp+0D0h+var_88], 0</span><br><span class="line">mov     [rbp+0D0h+Buf2], 1</span><br><span class="line">mov     [rbp+0D0h+Size], 0</span><br><span class="line">mov     r14d, 4</span><br><span class="line">mov     [rbp+0D0h+var_90], 0</span><br><span class="line">lea     rsi, a0123456789Abcd ; &quot;!\&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEF&quot;...</span><br><span class="line">lea     rdi, [rbp+0D0h+var_88]</span><br><span class="line">mov     [rbp+0D0h+var_F0], 0</span><br><span class="line">mov     [rbp+0D0h+var_F8], 0</span><br><span class="line">xor     edx, edx</span><br><span class="line">xor     r12d, r12d</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">mov     [rbp+0D0h+var_100], r11</span><br><span class="line">jmp     short loc_140002722</span><br></pre></td></tr></table></figure>
<p>后面又去看汇编，怀疑使用base64变种，试了之后发现不对，再去看汇编，同时问了下ai，发现这里还有别的加密，base85加密，往下看汇编，没有发现xor和别的加密<br>逻辑：flag先被base64加密，再进行base85加密，然后与&lt;AA;XAM?,_@;T[r@7E779h8;s&gt;’&#96;pt&#x3D;&gt;3c6ASuHFASOtP&lt;Gkf_A4&amp;gPAl1]S(ps:当时少看了一个s，后面才发现)<br><img src="/QMQ.github.io/images/geek/10.png"><br>SYC{Ohjhhh_y0u_g3t_Ezzzzz3_Ru3t!@}</p>
<h6 id="8-QYQSの奇妙冒险2"><a href="#8-QYQSの奇妙冒险2" class="headerlink" title="8.QYQSの奇妙冒险2"></a>8.QYQSの奇妙冒险2</h6><p>直接在字符串中搜<br> SYC{M@y_bE_y0u_F1nd?}
 </p>
<h6 id="9-ez-vm"><a href="#9-ez-vm" class="headerlink" title="9.ez_vm"></a>9.ez_vm</h6><p>大概逻辑：ida中的伪代码首先是global_vm给了一个初始值，然后设置虚拟机，预存数据，接着到主程序，用户输入一个数，经过vm_load_program函数进入虚拟机，经过一些操作，与预存的数据进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int v5; // [rsp+0h] [rbp-50h]</span><br><span class="line">  int v6; // [rsp+8h] [rbp-48h]</span><br><span class="line">  int v7; // [rsp+Ch] [rbp-44h]</span><br><span class="line">  int v8; // [rsp+18h] [rbp-38h]</span><br><span class="line">  int v9; // [rsp+28h] [rbp-28h]</span><br><span class="line">  int v10; // [rsp+38h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v5 = clock() % 100;</span><br><span class="line">  if ( v5 &gt; 50 &amp;&amp; ((123 * v5 + 456) ^ 0xDEADBEEF) == 0x12345678 )</span><br><span class="line">    exit(1);</span><br><span class="line">  global_vm = vm_init(4096LL, 1024LL);</span><br><span class="line">  if ( !global_vm )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(&quot;Failed to initialize VM\n&quot;, 1uLL, 0x18uLL, stderr);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = 2139337184;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( rand() % 1000 == -1717986919 )</span><br><span class="line">      exit(1);</span><br><span class="line">    v3 = (16 * v7) ^ v6;</span><br><span class="line">    if ( v3 != 2139337184 )</span><br><span class="line">      break;</span><br><span class="line">    v8 = clock() % 100;</span><br><span class="line">    if ( v8 &gt; 50 &amp;&amp; ((123 * v8 + 456) ^ 0xDEADBEEF) == 0x12345678 )</span><br><span class="line">      exit(1);</span><br><span class="line">    v6 = 1013904242;</span><br><span class="line">    v7 = 1;</span><br><span class="line">LABEL_33:</span><br><span class="line">    if ( rand() % 1000 == -1717986919 )</span><br><span class="line">      exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v3 &gt; 2139337184 )</span><br><span class="line">    goto LABEL_32;</span><br><span class="line">  if ( v3 == 1013904226 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( rand() % 1000 == -1717986919 )</span><br><span class="line">      exit(1);</span><br><span class="line">    sub_1a2b3c(global_vm, &amp;sub_5c6d7e, 3LL, 29LL);</span><br><span class="line">    v6 = -1655035833;</span><br><span class="line">    v7 = 2;</span><br><span class="line">    v9 = clock() % 100;</span><br><span class="line">    if ( v9 &gt; 50 &amp;&amp; ((123 * v9 + 456) ^ 0xDEADBEEF) == 0x12345678 )</span><br><span class="line">      exit(1);</span><br><span class="line">    goto LABEL_33;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v3 &gt; 1013904226 )</span><br><span class="line">    goto LABEL_32;</span><br><span class="line">  if ( v3 == -1655035801 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( rand() % 1000 == -1717986919 )</span><br><span class="line">      exit(1);</span><br><span class="line">    sub_9e8f7a(global_vm);</span><br><span class="line">    v6 = 457995832;</span><br><span class="line">    v7 = 3;</span><br><span class="line">    goto LABEL_33;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v3 != 457995784 )</span><br><span class="line">LABEL_32:</span><br><span class="line">    exit(1);</span><br><span class="line">  v10 = clock() % 100;</span><br><span class="line">  if ( v10 &gt; 50 &amp;&amp; ((123 * v10 + 456) ^ 0xDEADBEEF) == 0x12345678 )</span><br><span class="line">    exit(1);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_9e8f7a(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  size_t n; // [rsp+18h] [rbp-78h]</span><br><span class="line">  char s[104]; // [rsp+20h] [rbp-70h] BYREF</span><br><span class="line">  unsigned __int64 v4; // [rsp+88h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  printf(&quot;Please enter the input string: &quot;);</span><br><span class="line">  fgets(s, 100, stdin);</span><br><span class="line">  n = strlen(s);</span><br><span class="line">  if ( s[n - 1] == 10 )</span><br><span class="line">    s[n - 1] = 0;</span><br><span class="line">  n = strlen(s);</span><br><span class="line">  memcpy((void *)(*(_QWORD *)(a1 + 96) + 768LL), (const void *)(*(_QWORD *)(a1 + 96) + 256LL), 0x1DuLL);</span><br><span class="line">  memcpy((void *)(*(_QWORD *)(a1 + 96) + 512LL), s, n);</span><br><span class="line">  dword_50AC = n;</span><br><span class="line">  dword_50CC = 768;</span><br><span class="line">  dword_5134 = 768;</span><br><span class="line">  vm_load_program(a1, &amp;xor_compare_program, 37LL);</span><br><span class="line">  vm_run(a1);</span><br><span class="line">  if ( *(_QWORD *)(a1 + 32) )</span><br><span class="line">    puts(&quot;Success: Input matches processed string!&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Failure: Input does not match.&quot;);</span><br><span class="line">  return v4 - __readfsqword(0x28u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分细节<br>1.预存的数据：通过在gdb下断点，提取预存数据<br><img src="/QMQ.github.io/images/geek/8.png"><br><img src="/QMQ.github.io/images/geek/9.png"><br>2.通过这里看字节码，可以了解数据进行的操作，主要进行xor 5A</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">xor_compare_program db    1             ; DATA XREF: _sub_9e8f7a+111↑o</span><br><span class="line">.data:00000000000050A1                 db    1</span><br><span class="line">.data:00000000000050A2                 db 0FFh</span><br><span class="line">.data:00000000000050A3                 db    0</span><br><span class="line">.data:00000000000050A4                 db    0</span><br><span class="line">.data:00000000000050A5                 db    0</span><br><span class="line">.data:00000000000050A6                 db    0</span><br><span class="line">.data:00000000000050A7                 db    0</span><br><span class="line">.data:00000000000050A8                 db    1</span><br><span class="line">.data:00000000000050A9                 db    2</span><br><span class="line">.data:00000000000050AA                 db 0FFh</span><br><span class="line">.data:00000000000050AB                 db    0</span><br><span class="line">.data:00000000000050AC dword_50AC      dd 0                    ; DATA XREF: _sub_9e8f7a+EB↑w</span><br><span class="line">.data:00000000000050B0                 db    1</span><br><span class="line">.data:00000000000050B1                 db    3</span><br><span class="line">.data:00000000000050B2                 db 0FFh</span><br><span class="line">.data:00000000000050B3                 db    0</span><br><span class="line">.data:00000000000050B4                 db  5Ah ; Z</span><br><span class="line">.data:00000000000050B5                 db    0</span><br><span class="line">.data:00000000000050B6                 db    0</span><br><span class="line">.data:00000000000050B7                 db    0</span><br><span class="line">.data:00000000000050B8                 db    1</span><br><span class="line">.data:00000000000050B9                 db    4</span><br><span class="line">.data:00000000000050BA                 db 0FFh</span><br><span class="line">.data:00000000000050BB                 db    0</span><br><span class="line">.data:00000000000050BC                 db    1</span><br><span class="line">.data:00000000000050BD                 db    0</span><br><span class="line">.data:00000000000050BE                 db    0</span><br><span class="line">.data:00000000000050BF                 db    0</span><br><span class="line">.data:00000000000050C0                 db    1</span><br><span class="line">.data:00000000000050C1                 db    5</span><br><span class="line">.data:00000000000050C2                 db 0FFh</span><br><span class="line">.data:00000000000050C3                 db    0</span><br><span class="line">.data:00000000000050C4                 db    0</span><br><span class="line">.data:00000000000050C5                 db    2</span><br><span class="line">.data:00000000000050C6                 db    0</span><br><span class="line">.data:00000000000050C7                 db    0</span><br><span class="line">.data:00000000000050C8                 db    1</span><br><span class="line">.data:00000000000050C9                 db    7</span><br><span class="line">.data:00000000000050CA                 db 0FFh</span><br><span class="line">.data:00000000000050CB                 db    0</span><br></pre></td></tr></table></figure>
<p><img src="/QMQ.github.io/images/geek/7.png"><br>SYC{W31c0m3_t0_r3@1_r3verse!}</p>
<h6 id="10-GeekBinder"><a href="#10-GeekBinder" class="headerlink" title="10.GeekBinder"></a>10.GeekBinder</h6><p>首先下载文件，发现有非常多的文件，先看lib，发现里面只有一个文件，省去找关键so文件的时间，直接放进ida<br><img src="/QMQ.github.io/images/geek/6.png"><br>得到伪代码，找到attr_xor_cipher中的sub_1119,发现是一个简单的异或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_1119(__int64 a1, unsigned __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; // rax</span><br><span class="line">  unsigned __int64 i; // [rsp+20h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0LL; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    if ( i &gt;= a2 )</span><br><span class="line">      break;</span><br><span class="line">    *(_BYTE *)(a3 + i) = *(_BYTE *)(a1 + i) ^ aGeek2025[i % 8];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时结合attr_get_hidden_cipher，找到了a1的值，大胆猜测flag就是a1进行xor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall attr_get_hidden_cipher(_QWORD *a1, _QWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // [rsp+18h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  if ( !a1 || !a2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  v3 = malloc(0x5BuLL);</span><br><span class="line">  if ( !v3 )</span><br><span class="line">    return 4294967294LL;</span><br><span class="line">  *v3 = unk_2020;</span><br><span class="line">  v3[1] = unk_2028;</span><br><span class="line">  v3[2] = unk_2030;</span><br><span class="line">  v3[3] = unk_2038;</span><br><span class="line">  v3[4] = unk_2040;</span><br><span class="line">  v3[5] = unk_2048;</span><br><span class="line">  v3[6] = unk_2050;</span><br><span class="line">  v3[7] = unk_2058;</span><br><span class="line">  v3[8] = unk_2060;</span><br><span class="line">  v3[9] = unk_2068;</span><br><span class="line">  v3[10] = unk_2070;</span><br><span class="line">  *((_WORD *)v3 + 44) = unk_2078;</span><br><span class="line">  *((_BYTE *)v3 + 90) = unk_207A;</span><br><span class="line">  *a1 = v3;</span><br><span class="line">  *a2 = 91LL;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据这个写解密代码，发现就对了<br>exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">encrypted = bytes.fromhex(  </span><br><span class="line">    &quot;343C2610735E727C1E1F5405556F665D543A15195D5301461456163470036642&quot;  </span><br><span class="line">    &quot;02000B3474595E50543A54186D535D5B131725194B6F665A380B55195F705E6A&quot;    &quot;171725084659510638540B3460556D500902540557554004090218&quot;)  </span><br><span class="line">  </span><br><span class="line">key = b&quot;geek2025&quot; </span><br><span class="line">  </span><br><span class="line">result = []  </span><br><span class="line">for i in range(len(encrypted)):  </span><br><span class="line">    dec = encrypted[i] ^ key[i % 8]  </span><br><span class="line">    result.append(dec)  </span><br><span class="line">    if i &lt; 50: </span><br><span class="line">        char = chr(dec) if 32 &lt;= dec &lt; 127 else f&#x27;[&#123;dec:02x&#125;]&#x27;  </span><br><span class="line">        print(f&quot;&#123;i:2d&#125;: &#123;encrypted[i]:02x&#125;^&#123;key[i%8]:02x&#125;=&#123;dec:02x&#125; &#123;char&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">flag_bytes = bytes(result)  </span><br><span class="line">print(&quot;\n完整解密:&quot;)  </span><br><span class="line">print(repr(flag_bytes.decode(&#x27;utf-8&#x27;, errors=&#x27;replace&#x27;)))</span><br></pre></td></tr></table></figure>
<p>SYC{An@Iyz1ng_Th3_proc3ss3s_B3Tween_File3_1s_contr@ry_To_n0rm@l_pr@ctic3_1n_Re_eng1neer1ng}</p>
<h6 id="11-Mission-Ghost-Signal"><a href="#11-Mission-Ghost-Signal" class="headerlink" title="11.Mission Ghost Signal"></a>11.Mission Ghost Signal</h6><p>伪代码，发现sub_402B57，sub_401C08比较关键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int sub_402DB1()</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v1[32]; // [esp+1Ch] [ebp-20Ch] BYREF</span><br><span class="line">  char v2[192]; // [esp+3Ch] [ebp-1ECh] BYREF</span><br><span class="line">  char Buffer[256]; // [esp+FCh] [ebp-12Ch] BYREF</span><br><span class="line">  _BYTE v4[16]; // [esp+1FCh] [ebp-2Ch] BYREF</span><br><span class="line">  int v5; // [esp+20Ch] [ebp-1Ch]</span><br><span class="line">  int j; // [esp+210h] [ebp-18h]</span><br><span class="line">  char v7; // [esp+217h] [ebp-11h]</span><br><span class="line">  int i; // [esp+218h] [ebp-10h]</span><br><span class="line">  size_t v9; // [esp+21Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  sub_403500();</span><br><span class="line">  SetConsoleOutputCP(0xFDE9u);</span><br><span class="line">  SetConsoleCP(0xFDE9u);</span><br><span class="line">  qmemcpy(v4, &quot;1145141145144332&quot;, sizeof(v4));</span><br><span class="line">  puts(&quot;密码验证系统&quot;);</span><br><span class="line">  printf(&quot;请输入压缩包密码: &quot;);</span><br><span class="line">  if ( fgets(Buffer, 256, (FILE *)iob[0]._ptr) )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = strlen(Buffer);</span><br><span class="line">    if ( v9 &amp;&amp; Buffer[v9 - 1] == 10 )</span><br><span class="line">      Buffer[--v9] = 0;</span><br><span class="line">    if ( v9 == 25 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_401C08(v2, aSyclover2025ge, v4);</span><br><span class="line">      memcpy(v1, Buffer, 0x19u);</span><br><span class="line">      v5 = 7;</span><br><span class="line">      for ( i = 25; i &lt;= 31; ++i )</span><br><span class="line">        v1[i] = v5;</span><br><span class="line">      sub_402B57(v2, v1, 32);</span><br><span class="line">      v7 = 1;</span><br><span class="line">      for ( j = 0; j &lt;= 31; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( byte_406020[j] != v1[j] )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = 0;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( v7 )</span><br><span class="line">        puts(&quot;恭喜！这是正确的压缩包密码。&quot;);</span><br><span class="line">      else</span><br><span class="line">        puts(&quot;特工，你失败了！密码不正确。&quot;);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;特工，你失败了！密码长度不正确。&quot;);</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;输入错误！&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看sub_402B57，发现是 AES-128 加密</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl sub_402992(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int8 i; // [esp+1Bh] [ebp-1h]</span><br><span class="line"></span><br><span class="line">  sub_401CA0(0, a1, a2);</span><br><span class="line">  for ( i = 1; i &lt;= 9u; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_401D41(a1);</span><br><span class="line">    sub_401DB1(a1);</span><br><span class="line">    sub_401EA2(a1);</span><br><span class="line">    sub_401CA0(i, a1, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_401D41(a1);</span><br><span class="line">  sub_401DB1(a1);</span><br><span class="line">  return sub_401CA0(10, a1, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再进行每段函数的查看，发现自定义S盒（动调得到），自定义Rcon表。根据这个写出解密函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rdata:00407064 byte_407064     db 8Dh                  ; DATA XREF: sub_4019B7+189↑r</span><br><span class="line">.rdata:00407065                 db    1</span><br><span class="line">.rdata:00407066                 db    2</span><br><span class="line">.rdata:00407067                 db    4</span><br><span class="line">.rdata:00407068                 db    8</span><br><span class="line">.rdata:00407069                 db  10h</span><br><span class="line">.rdata:0040706A                 db  20h</span><br><span class="line">.rdata:0040706B                 db  40h ; @</span><br><span class="line">.rdata:0040706C                 db  80h</span><br><span class="line">.rdata:0040706D                 db  1Bh</span><br><span class="line">.rdata:0040706E                 db  36h ; 6</span><br></pre></td></tr></table></figure>
<p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line"># 自定义S盒</span><br><span class="line">S_BOX = [</span><br><span class="line">    0xA7, 0xB8, 0x36, 0xAF, 0x0E, 0x46, 0x3E, 0x9D, 0xCD, 0x47, 0xDF, 0xAA, 0x97, 0x15, 0xE4, 0x38,</span><br><span class="line">    0x6B, 0x66, 0x04, 0xB6, 0xEF, 0xA3, 0xB2, 0x6F, 0xFD, 0x7A, 0x0B, 0x9C, 0x77, 0x12, 0x40, 0xEB,</span><br><span class="line">    0x94, 0xF8, 0x81, 0x3D, 0xD4, 0x3B, 0x78, 0x72, 0xB5, 0x1C, 0xF0, 0x61, 0x2F, 0xE3, 0xC3, 0xD6,</span><br><span class="line">    0x31, 0xFC, 0x4B, 0x84, 0x41, 0xF7, 0x3F, 0x6E, 0x5E, 0xC1, 0x07, 0xE7, 0x08, 0x33, 0xE2, 0x57,</span><br><span class="line">    0xA6, 0x68, 0xBD, 0x20, 0x2E, 0x30, 0xCC, 0x6A, 0x2D, 0x43, 0x1B, 0xEC, 0xCB, 0xE9, 0xD2, 0x7F,</span><br><span class="line">    0x23, 0x0C, 0x49, 0x11, 0x24, 0xF6, 0x8D, 0xC2, 0x48, 0x65, 0x7B, 0x22, 0x25, 0x3C, 0xAD, 0x1D,</span><br><span class="line">    0x02, 0x70, 0xEA, 0xE1, 0xCA, 0x32, 0xA2, 0x71, 0xD3, 0x80, 0x28, 0xD7, 0x4C, 0x54, 0x18, 0x8B,</span><br><span class="line">    0x42, 0x05, 0xA5, 0xF1, 0x8F, 0x79, 0x2C, 0x19, 0x1A, 0x9A, 0x82, 0x2A, 0xA0, 0x99, 0x00, 0x63,</span><br><span class="line">    0x7C, 0xD0, 0xCF, 0x1F, 0xBA, 0xF9, 0xDD, 0xB7, 0x93, 0x7D, 0xD9, 0x5A, 0xB0, 0xDB, 0x4F, 0x4E,</span><br><span class="line">    0xC8, 0x09, 0x53, 0x9B, 0x45, 0xA4, 0xEE, 0xE6, 0xBC, 0x7E, 0x62, 0xD8, 0xFA, 0xB4, 0xC7, 0x8C,</span><br><span class="line">    0x86, 0xAC, 0x4D, 0xC9, 0x4A, 0x50, 0x5C, 0xD5, 0x8A, 0x6D, 0xF3, 0xA9, 0xE0, 0x98, 0xFE, 0xCE,</span><br><span class="line">    0x91, 0x0A, 0xDA, 0x5F, 0x90, 0x74, 0x5D, 0x85, 0x51, 0x55, 0x17, 0x06, 0xBE, 0xA1, 0x92, 0xA8,</span><br><span class="line">    0x03, 0xC0, 0x52, 0xDC, 0x39, 0x73, 0xFB, 0xF2, 0x67, 0x95, 0x59, 0x56, 0x2B, 0x14, 0x89, 0x87,</span><br><span class="line">    0x21, 0x35, 0xF5, 0xD1, 0x44, 0x26, 0x76, 0xB1, 0xC6, 0xBB, 0x5B, 0x6C, 0x1E, 0xE5, 0x37, 0x16,</span><br><span class="line">    0x88, 0x8E, 0x0F, 0xAE, 0x27, 0xED, 0xFF, 0x96, 0x60, 0x58, 0x10, 0x69, 0x13, 0x3A, 0xC5, 0xF4,</span><br><span class="line">    0x9E, 0x64, 0xE8, 0xDE, 0x75, 0x9F, 0xC4, 0x29, 0xAB, 0x01, 0xB3, 0xBF, 0x83, 0x34, 0x0D, 0xB9</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 生成逆S盒</span><br><span class="line">INV_S_BOX = [0] * 256</span><br><span class="line">for i in range(256):</span><br><span class="line">    INV_S_BOX[S_BOX[i]] = i</span><br><span class="line"></span><br><span class="line"># Rcon表</span><br><span class="line">RCON = [0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]</span><br><span class="line"></span><br><span class="line"># 密文</span><br><span class="line">ciphertext = bytes([</span><br><span class="line">    0xB2, 0xB3, 0xDC, 0xB9, 0xF8, 0xD6, 0x93, 0xFF, 0xB5, 0xA1,</span><br><span class="line">    0xCC, 0x2A, 0x6F, 0xDE, 0x27, 0x44, 0xAF, 0x21, 0x98, 0xDD,</span><br><span class="line">    0x00, 0xC1, 0x0D, 0x1C, 0x53, 0x06, 0x81, 0x3E, 0x16, 0xAB,</span><br><span class="line">    0xDF, 0x13</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 密钥和IV</span><br><span class="line">KEY = b&quot;Syclover2025Geek&quot;</span><br><span class="line">IV = b&quot;1145141145144332&quot;</span><br><span class="line"></span><br><span class="line"># GF(2^8)乘法</span><br><span class="line">def gf_mult(a, b):</span><br><span class="line">    &quot;&quot;&quot;GF(2^8)乘法&quot;&quot;&quot;</span><br><span class="line">    p = 0</span><br><span class="line">    a_val = a &amp; 0xFF</span><br><span class="line">    b_val = b &amp; 0xFF</span><br><span class="line"></span><br><span class="line">    for _ in range(8):</span><br><span class="line">        if b_val &amp; 1:</span><br><span class="line">            p ^= a_val</span><br><span class="line">        hi_bit = a_val &amp; 0x80</span><br><span class="line">        a_val = (a_val &lt;&lt; 1) &amp; 0xFF</span><br><span class="line">        if hi_bit:</span><br><span class="line">            a_val ^= 0x1B</span><br><span class="line">        b_val &gt;&gt;= 1</span><br><span class="line"></span><br><span class="line">    return p &amp; 0xFF</span><br><span class="line"></span><br><span class="line"># 密钥扩展</span><br><span class="line">def key_expansion(key):</span><br><span class="line">    &quot;&quot;&quot;生成轮密钥&quot;&quot;&quot;</span><br><span class="line">    key_bytes = list(key)</span><br><span class="line">    w = []</span><br><span class="line">    </span><br><span class="line">    # 初始4个字</span><br><span class="line">    for i in range(4):</span><br><span class="line">        w.append(key_bytes[4*i:4*i+4])</span><br><span class="line">    </span><br><span class="line">    # 扩展到44个字</span><br><span class="line">    for i in range(4, 44):</span><br><span class="line">        temp = w[i-1][:]</span><br><span class="line">        </span><br><span class="line">        if i % 4 == 0:</span><br><span class="line">            # RotWord</span><br><span class="line">            temp = [temp[1], temp[2], temp[3], temp[0]]</span><br><span class="line">            # SubWord</span><br><span class="line">            temp = [S_BOX[b] for b in temp]</span><br><span class="line">            # XOR Rcon</span><br><span class="line">            temp[0] ^= RCON[i//4]</span><br><span class="line">        </span><br><span class="line">        # XOR</span><br><span class="line">        w.append([w[i-4][j] ^ temp[j] for j in range(4)])</span><br><span class="line">    </span><br><span class="line">    return w</span><br><span class="line"></span><br><span class="line"># 逆列混淆</span><br><span class="line">def inv_mix_columns(state):</span><br><span class="line">    &quot;&quot;&quot;逆列混合&quot;&quot;&quot;</span><br><span class="line">    for col in range(4):</span><br><span class="line">        s0, s1, s2, s3 = state[col*4:col*4+4]</span><br><span class="line">        </span><br><span class="line">        state[col*4+0] = gf_mult(s0, 0x0e) ^ gf_mult(s1, 0x0b) ^ gf_mult(s2, 0x0d) ^ gf_mult(s3, 0x09)</span><br><span class="line">        state[col*4+1] = gf_mult(s0, 0x09) ^ gf_mult(s1, 0x0e) ^ gf_mult(s2, 0x0b) ^ gf_mult(s3, 0x0d)</span><br><span class="line">        state[col*4+2] = gf_mult(s0, 0x0d) ^ gf_mult(s1, 0x09) ^ gf_mult(s2, 0x0e) ^ gf_mult(s3, 0x0b)</span><br><span class="line">        state[col*4+3] = gf_mult(s0, 0x0b) ^ gf_mult(s1, 0x0d) ^ gf_mult(s2, 0x09) ^ gf_mult(s3, 0x0e)</span><br><span class="line"></span><br><span class="line"># 逆行移位</span><br><span class="line">def inv_shift_rows(state):</span><br><span class="line">    &quot;&quot;&quot;逆行移位&quot;&quot;&quot;</span><br><span class="line">    # 第1行：右移1位</span><br><span class="line">    state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]</span><br><span class="line">    </span><br><span class="line">    # 第2行：右移2位</span><br><span class="line">    state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]</span><br><span class="line">    </span><br><span class="line">    # 第3行：右移3位</span><br><span class="line">    state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]</span><br><span class="line"></span><br><span class="line"># 逆字节替换</span><br><span class="line">def inv_sub_bytes(state):</span><br><span class="line">    for i in range(16):</span><br><span class="line">        state[i] = INV_S_BOX[state[i]]</span><br><span class="line"></span><br><span class="line"># 轮密钥加</span><br><span class="line">def add_round_key(state, round_keys, round_num):</span><br><span class="line">    &quot;&quot;&quot;轮密钥加&quot;&quot;&quot;</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            state[i*4+j] ^= round_keys[round_num*4+i][j]</span><br><span class="line"></span><br><span class="line"># 解密单个块</span><br><span class="line">def decrypt_block(block, round_keys):</span><br><span class="line">    &quot;&quot;&quot;解密一个16字节块&quot;&quot;&quot;</span><br><span class="line">    state = list(block)</span><br><span class="line">    </span><br><span class="line">    # 第10轮</span><br><span class="line">    add_round_key(state, round_keys, 10)</span><br><span class="line">    </span><br><span class="line">    # 第9到第1轮</span><br><span class="line">    for round_num in range(9, 0, -1):</span><br><span class="line">        inv_shift_rows(state)</span><br><span class="line">        inv_sub_bytes(state)</span><br><span class="line">        add_round_key(state, round_keys, round_num)</span><br><span class="line">        inv_mix_columns(state)</span><br><span class="line">    </span><br><span class="line">    # 第0轮</span><br><span class="line">    inv_shift_rows(state)</span><br><span class="line">    inv_sub_bytes(state)</span><br><span class="line">    add_round_key(state, round_keys, 0)</span><br><span class="line">    </span><br><span class="line">    return bytes(state)</span><br><span class="line"></span><br><span class="line"># CBC模式解密</span><br><span class="line">def cbc_decrypt(ciphertext, key, iv):</span><br><span class="line">    &quot;&quot;&quot;CBC模式解密&quot;&quot;&quot;</span><br><span class="line">    round_keys = key_expansion(key)</span><br><span class="line">    plaintext = bytearray()</span><br><span class="line">    prev_block = iv</span><br><span class="line">    </span><br><span class="line">    for i in range(0, len(ciphertext), 16):</span><br><span class="line">        block = ciphertext[i:i+16]</span><br><span class="line">        decrypted = decrypt_block(block, round_keys)</span><br><span class="line">        </span><br><span class="line">        # XOR操作</span><br><span class="line">        plain_block = bytes(a ^ b for a, b in zip(decrypted, prev_block))</span><br><span class="line">        plaintext.extend(plain_block)</span><br><span class="line">        </span><br><span class="line">        prev_block = block</span><br><span class="line">    </span><br><span class="line">    return bytes(plaintext)</span><br><span class="line"></span><br><span class="line"># 移除填充</span><br><span class="line">def remove_padding(data):</span><br><span class="line">    &quot;&quot;&quot;移除PKCS#7填充&quot;&quot;&quot;</span><br><span class="line">    if not data:</span><br><span class="line">        return data</span><br><span class="line">    </span><br><span class="line">    pad_len = data[-1]</span><br><span class="line">    if pad_len &lt; 1 or pad_len &gt; 16:</span><br><span class="line">        return data</span><br><span class="line">    </span><br><span class="line">    # 检查填充</span><br><span class="line">    if all(data[-i] == pad_len for i in range(1, pad_len + 1)):</span><br><span class="line">        return data[:-pad_len]</span><br><span class="line">    </span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    print(&quot;开始解密...&quot;)</span><br><span class="line">    print(f&quot;密文长度: &#123;len(ciphertext)&#125; 字节&quot;)</span><br><span class="line">    </span><br><span class="line">    # 解密</span><br><span class="line">    decrypted = cbc_decrypt(ciphertext, KEY, IV)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;\n解密后数据 (32字节):&quot;)</span><br><span class="line">    print(decrypted.hex())</span><br><span class="line">    </span><br><span class="line">    # 移除填充</span><br><span class="line">    plaintext = remove_padding(decrypted)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;\n移除填充后 (&#123;len(plaintext)&#125;字节):&quot;)</span><br><span class="line">    print(plaintext.hex())</span><br><span class="line">    </span><br><span class="line">    # 尝试解码为字符串</span><br><span class="line">    try:</span><br><span class="line">        text = plaintext.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)</span><br><span class="line">        print(f&quot;\n可读文本: &#123;text&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">        # 检查flag格式</span><br><span class="line">        if &#x27;flag&#x27; in text.lower() or &#x27;&#123;&#x27; in text:</span><br><span class="line">            print(f&quot;\n可能的flag: &#123;text&#125;&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    return plaintext</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    result = main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将音频放到sstv中后得到了二维码，扫描后下载，又得到一个音频，将它放到解摩斯密码的网站，得到数据，再放到cyberchef进行解密<br><img src="/QMQ.github.io/images/geek/1.png"><br><img src="/QMQ.github.io/images/geek/5.png"><br><img src="/QMQ.github.io/images/geek/3.png"><br>SYC{7h15_1S_4_9r4nD_c0N5p1r@cY.}</p>
<h6 id="12-reReverse"><a href="#12-reReverse" class="headerlink" title="12.reReverse"></a>12.reReverse</h6><p>点进main中，发现根本没有什么有用的信息，想到之前的题可能是将真正的加密函数，隐藏了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, __int64 a2, void (*a3)(void), double a4, __m128 _XMM1)</span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; vpsrlw  xmm2, xmm1, 4 &#125;</span><br><span class="line">  start(a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就点开了字符串发现input，no_win这个关键信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000401074	00000009	C	input：</span><br><span class="line">.rodata:000000000040107D	0000000C	C	len erro！</span><br><span class="line">.rodata:0000000000401089	00000007	C	no_win</span><br></pre></td></tr></table></figure>
<p>根据上面的关键信息，发现一大群标红的代码，猜测这里就是真正加密的地方，这里只取了一部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400D8E                 call    _fgets</span><br><span class="line">.text:0000000000400D93                 mov     rdi, rbx</span><br><span class="line">.text:0000000000400D96                 mov     esi, 64h ; &#x27;d&#x27;</span><br><span class="line">.text:0000000000400D9B                 mov     rdx, cs:stdin</span><br><span class="line">.text:0000000000400DA2                 call    ___printf_chk</span><br><span class="line">.text:0000000000400DA7                 movaps  xmmword ptr [rsp+30h], xmm0</span><br><span class="line">.text:0000000000400DAC                 lea     rbx, [rsp+40h]</span><br><span class="line">.text:0000000000400DB1                 xor     eax, eax</span><br><span class="line">.text:0000000000400DB3                 mov     [rsp+0A8h], rax</span><br><span class="line">.text:0000000000400DBB                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000400DC4                 movdqa  xmm0, cs:xmmword_401090</span><br><span class="line">.text:0000000000400DCC                 sub     rsp, 0B8h</span><br><span class="line">.text:0000000000400DD3                 push    rbx</span><br><span class="line">.text:0000000000400DD4                 push    rbp</span><br><span class="line">.text:0000000000400DD5                 push    r12</span><br><span class="line">.text:0000000000400DD7                 push    r13</span><br><span class="line">.text:0000000000400DD9                 push    r14</span><br><span class="line">.text:0000000000400DDB                 mov     edi, 1</span><br><span class="line">.text:0000000000400DE0                 lea     rsi, aInput     ; &quot;input：&quot;</span><br><span class="line">.text:0000000000400DE7                 push    r15</span><br><span class="line">.text:0000000000400DE9                 endbr64</span><br></pre></td></tr></table></figure>
<p>先是简单的看了一下，发现看到我头疼，但是看到一个关键信息0x9E3779B9，是tea系列的标志，但是是哪一个我没看出来，然后把这个丢给ai，ai一开始说是xtea，结果死活解不出，后面看了一下官方wp说是xxtea，在ai的帮助下，找到了是xxtea的证据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shr     r13d, 5             </span><br><span class="line">shl     r14d, 4                </span><br><span class="line">shr     r12d, 3              </span><br><span class="line">lea     r12d, ds:0[r9*4]     </span><br></pre></td></tr></table></figure>
<p>这四个位移量(5, 4, 3, 2)是XXTEA MX宏的标准配置，后面也没有魔改，是标准的xxtea<br>exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  </span><br><span class="line">import struct  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def u32(x):  </span><br><span class="line">    return x &amp; 0xFFFFFFFF  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def xxtea_decrypt(v, key):  </span><br><span class="line">  </span><br><span class="line">    def MX(z, y, sum_val, p, e, k):  </span><br><span class="line">        return ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum_val ^ y) + (k[p &amp; 3 ^ e] ^ z))  </span><br><span class="line">  </span><br><span class="line">    n = len(v)  </span><br><span class="line">    delta = 0x9E3779B9  </span><br><span class="line">    rounds = 6 + 52 // n  </span><br><span class="line">    sum_val = (rounds * delta) &amp; 0xFFFFFFFF  </span><br><span class="line">  </span><br><span class="line">    y = v[0]  </span><br><span class="line">    while rounds &gt; 0:  </span><br><span class="line">        e = (sum_val &gt;&gt; 2) &amp; 3  </span><br><span class="line">        for p in range(n - 1, 0, -1):  </span><br><span class="line">            z = v[p - 1]  </span><br><span class="line">            v[p] = (v[p] - MX(z, y, sum_val, p, e, key)) &amp; 0xFFFFFFFF  </span><br><span class="line">            y = v[p]  </span><br><span class="line">        z = v[n - 1]  </span><br><span class="line">        v[0] = (v[0] - MX(z, y, sum_val, 0, e, key)) &amp; 0xFFFFFFFF  </span><br><span class="line">        y = v[0]  </span><br><span class="line">        sum_val = (sum_val - delta) &amp; 0xFFFFFFFF  </span><br><span class="line">        rounds -= 1  </span><br><span class="line">  </span><br><span class="line">    return v  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"># 密文  </span><br><span class="line">ciphertext = [  </span><br><span class="line">    0x2973BD37, 0x1BA99AA3, 0xB3C20088, 0xBFC393AB, 0x352ADCCF,  </span><br><span class="line">    0x3B98E6E6, 0xAE421991, 0xD7B702CF, 0x0EEF6889, 0x08662435  </span><br><span class="line">]  </span><br><span class="line">  </span><br><span class="line"># 密钥  </span><br><span class="line">key = [0xDEAD, 0xBEEF, 0x5A7D, 0xC0FF]  </span><br><span class="line">  </span><br><span class="line"># 解密  </span><br><span class="line">plaintext = ciphertext.copy()  </span><br><span class="line">xxtea_decrypt(plaintext, key)  </span><br><span class="line">  </span><br><span class="line"># 转换为字节  </span><br><span class="line">flag_bytes = b&#x27;&#x27;.join(struct.pack(&#x27;&lt;I&#x27;, u32(x)) for x in plaintext)  </span><br><span class="line">  </span><br><span class="line">print(&quot;解密结果:&quot;)  </span><br><span class="line">print(f&quot;十六进制: &#123;flag_bytes.hex()&#125;&quot;)  </span><br><span class="line">print(f&quot;原始字节: &#123;repr(flag_bytes)&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>SYC{sakurakouji_runasama_wa_seikai_ichi}<br>总结：这个题里面的混淆太多了，如果没有ai的帮助，我都认不出哪里被混淆，哪里是加密，还有对tea家族不太了解，ai说是xtea就信了，浪费了半天，后面得翻官方wp。</p>
<h6 id="13-ez-android"><a href="#13-ez-android" class="headerlink" title="13.ez_android"></a>13.ez_android</h6><p>因为之前遇到过类似的，知道加密的函数位于lib中，所以直接点开了lib，发现有四个文件夹，以为有很多的so，没想到每个文件夹的so不仅少，还是一样的。然后将libwrapper.so放到ida里去，发现这里不是真正的so，还要把真正的so提出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall load_real_so(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  int *v1; // rax</span><br><span class="line">  int *v2; // rax</span><br><span class="line">  void *handle; // [rsp+8h] [rbp-88h]</span><br><span class="line">  int fd; // [rsp+14h] [rbp-7Ch]</span><br><span class="line">  void *ptr; // [rsp+18h] [rbp-78h]</span><br><span class="line"></span><br><span class="line">  ptr = malloc(encrypted_so_len);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __memcpy_chk((__int64)ptr, (__int64)&amp;encrypted_so, encrypted_so_len, -1LL);</span><br><span class="line">    decrypt_xor((__int64)ptr, encrypted_so_len, 170);</span><br><span class="line">    fd = open(a1, 578, 448LL);</span><br><span class="line">    if ( fd &gt;= 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( __write_chk((unsigned int)fd, ptr, encrypted_so_len, -1LL) == encrypted_so_len )</span><br><span class="line">      &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        free(ptr);</span><br><span class="line">        handle = dlopen(a1, 2);</span><br><span class="line">        if ( handle )</span><br><span class="line">        &#123;</span><br><span class="line">          qword_AEE8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))dlsym(</span><br><span class="line">                                                                         handle,</span><br><span class="line">                                                                         &quot;Java_com_example_syc_function2_function2&quot;);</span><br><span class="line">          if ( qword_AEE8 )</span><br><span class="line">          &#123;</span><br><span class="line">            __android_log_print(3LL, (__int64)&quot;wrapper&quot;, &quot;Real SO loaded successfully!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">            dlerror();</span><br><span class="line">            __android_log_print(3LL, (__int64)&quot;wrapper&quot;, &quot;dlsym error: %s&quot;);</span><br><span class="line">            dlclose(handle);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          dlerror();</span><br><span class="line">          __android_log_print(3LL, (__int64)&quot;wrapper&quot;, &quot;dlopen error: %s&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v2 = (int *)__errno();</span><br><span class="line">        strerror(*v2);</span><br><span class="line">        __android_log_print(3LL, (__int64)&quot;wrapper&quot;, &quot;write failed: %s&quot;);</span><br><span class="line">        close(fd);</span><br><span class="line">        free(ptr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = (int *)__errno();</span><br><span class="line">      strerror(*v1);</span><br><span class="line">      __android_log_print(3LL, (__int64)&quot;wrapper&quot;, &quot;open tmp file failed: %s&quot;);</span><br><span class="line">      free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    __android_log_print(3LL, (__int64)&quot;wrapper&quot;, &quot;malloc failed&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在还写不了，就让ai给我写了一份提取脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">import struct  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def extract_encrypted_so(input_file, output_file):  </span><br><span class="line">    &quot;&quot;&quot;提取加密的SO文件&quot;&quot;&quot;  </span><br><span class="line">  </span><br><span class="line">    with open(input_file, &#x27;rb&#x27;) as f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">  </span><br><span class="line">    print(&quot;[*] 分析 ELF 段信息...&quot;)  </span><br><span class="line">    print(f&quot;[*] 文件大小: 0x&#123;len(data):X&#125; 字节 (&#123;len(data)&#125; 字节)&quot;)  </span><br><span class="line">  </span><br><span class="line">    # 计算文件偏移  </span><br><span class="line">    offset_difference = 0x8000  # 内存地址 - 文件偏移  </span><br><span class="line">  </span><br><span class="line">    # 1. 加密数据位置 (内存 0x9420 -&gt; 文件 0x1420)    va_encrypted = 0x9420  </span><br><span class="line">    file_encrypted = va_encrypted - offset_difference  # 0x1420  </span><br><span class="line">  </span><br><span class="line">    # 2. 长度信息位置 (内存 0xAEE0 -&gt; 文件 0x2EE0)    va_length = 0xAEE0  </span><br><span class="line">    file_length = va_length - offset_difference  # 0x2EE0  </span><br><span class="line">  </span><br><span class="line">    print(f&quot;[*] 加密数据位置: 内存 0x&#123;va_encrypted:X&#125; -&gt; 文件 0x&#123;file_encrypted:X&#125;&quot;)  </span><br><span class="line">    print(f&quot;[*] 长度信息位置: 内存 0x&#123;va_length:X&#125; -&gt; 文件 0x&#123;file_length:X&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">    # 3. 验证文件偏移是否有效  </span><br><span class="line">    if file_length + 4 &gt; len(data):  </span><br><span class="line">        print(f&quot;[!] 错误: 长度信息超出文件范围&quot;)  </span><br><span class="line">        print(f&quot;    文件大小: 0x&#123;len(data):X&#125;, 需要读取: 0x&#123;file_length + 4:X&#125;&quot;)  </span><br><span class="line">        return False  </span><br><span class="line">  </span><br><span class="line">    # 4. 读取长度信息 (小端序)  </span><br><span class="line">    encrypted_len = struct.unpack(&#x27;&lt;I&#x27;, data[file_length:file_length + 4])[0]  </span><br><span class="line">    print(f&quot;[*] 加密数据长度: 0x&#123;encrypted_len:X&#125; (&#123;encrypted_len&#125; 字节)&quot;)  </span><br><span class="line">  </span><br><span class="line">    # 5. 验证加密数据范围  </span><br><span class="line">    if file_encrypted + encrypted_len &gt; len(data):  </span><br><span class="line">        print(f&quot;[!] 错误: 加密数据超出文件范围&quot;)  </span><br><span class="line">        print(f&quot;    文件大小: 0x&#123;len(data):X&#125;, 需要读取: 0x&#123;file_encrypted + encrypted_len:X&#125;&quot;)  </span><br><span class="line">        return False  </span><br><span class="line">  </span><br><span class="line">    # 6. 提取加密数据  </span><br><span class="line">    encrypted_data = data[file_encrypted:file_encrypted + encrypted_len]  </span><br><span class="line">    print(f&quot;[*] 提取加密数据: 0x&#123;len(encrypted_data):X&#125; 字节&quot;)  </span><br><span class="line">  </span><br><span class="line">    # 7. XOR 解密 (密钥 0xAA)    decrypted_data = bytes([b ^ 0xAA for b in encrypted_data])  </span><br><span class="line">  </span><br><span class="line">    # 8. 验证是否是 ELF 文件  </span><br><span class="line">    if decrypted_data[:4] == b&#x27;\x7fELF&#x27;:  </span><br><span class="line">        print(&quot;[+] 解密成功！是有效的 ELF 文件&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 显示 ELF 基本信息  </span><br><span class="line">        e_type = struct.unpack(&#x27;&lt;H&#x27;, decrypted_data[0x10:0x12])[0]  </span><br><span class="line">        e_machine = struct.unpack(&#x27;&lt;H&#x27;, decrypted_data[0x12:0x14])[0]  </span><br><span class="line">        e_entry = struct.unpack(&#x27;&lt;Q&#x27;, decrypted_data[0x18:0x20])[0]  </span><br><span class="line">  </span><br><span class="line">        print(f&quot;[*] ELF 类型: 0x&#123;e_type:X&#125;&quot;)  </span><br><span class="line">        print(f&quot;[*] 机器类型: 0x&#123;e_machine:X&#125;&quot;)  </span><br><span class="line">        print(f&quot;[*] 入口地址: 0x&#123;e_entry:X&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 检查是否包含目标函数  </span><br><span class="line">        target_func = b&#x27;Java_com_example_syc_function2_function2&#x27;  </span><br><span class="line">        if target_func in decrypted_data:  </span><br><span class="line">            print(&quot;[+] 包含目标函数: Java_com_example_syc_function2_function2&quot;)  </span><br><span class="line">  </span><br><span class="line">            # 查找函数位置  </span><br><span class="line">            idx = decrypted_data.find(target_func)  </span><br><span class="line">            print(f&quot;[*] 函数字符串位置: 0x&#123;idx:X&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 9. 保存解密后的文件  </span><br><span class="line">        with open(output_file, &#x27;wb&#x27;) as f:  </span><br><span class="line">            f.write(decrypted_data)  </span><br><span class="line">  </span><br><span class="line">        print(f&quot;[+] 已保存解密文件: &#123;output_file&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 10. 进一步验证  </span><br><span class="line">        try:  </span><br><span class="line">            # 检查程序头表数量  </span><br><span class="line">            e_phnum = struct.unpack(&#x27;&lt;H&#x27;, decrypted_data[0x38:0x3A])[0]  </span><br><span class="line">            e_shnum = struct.unpack(&#x27;&lt;H&#x27;, decrypted_data[0x3C:0x3E])[0]  </span><br><span class="line">            print(f&quot;[*] 程序头数量: &#123;e_phnum&#125;&quot;)  </span><br><span class="line">            print(f&quot;[*] 节头数量: &#123;e_shnum&#125;&quot;)  </span><br><span class="line">        except:  </span><br><span class="line">            pass  </span><br><span class="line">  </span><br><span class="line">        return True    else:  </span><br><span class="line">        print(&quot;[!] 解密失败，不是有效的 ELF 文件&quot;)  </span><br><span class="line">        print(f&quot;[*] 解密数据前16字节: &#123;decrypted_data[:16].hex()&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 尝试其他常见密钥  </span><br><span class="line">        common_keys = [0xAA, 0x55, 0xFF, 0x00, 0x33, 0xCC, 0x66, 0x99]  </span><br><span class="line">        for key in common_keys:  </span><br><span class="line">            test_data = bytes([b ^ key for b in encrypted_data[:4]])  </span><br><span class="line">            if test_data == b&#x27;\x7fELF&#x27;:  </span><br><span class="line">                print(f&quot;[*] 尝试其他密钥 0x&#123;key:02X&#125; 成功！&quot;)  </span><br><span class="line">                decrypted_data = bytes([b ^ key for b in encrypted_data])  </span><br><span class="line">  </span><br><span class="line">                with open(output_file, &#x27;wb&#x27;) as f:  </span><br><span class="line">                    f.write(decrypted_data)  </span><br><span class="line">                print(f&quot;[+] 已用密钥 0x&#123;key:02X&#125; 解密并保存&quot;)  </span><br><span class="line">                return True  </span><br><span class="line">  </span><br><span class="line">        return False  </span><br><span class="line">  </span><br><span class="line"># 直接查看文件内容验证  </span><br><span class="line">def verify_extraction(input_file):  </span><br><span class="line">    &quot;&quot;&quot;验证提取是否正确&quot;&quot;&quot;  </span><br><span class="line">    with open(input_file, &#x27;rb&#x27;) as f:  </span><br><span class="line">        # 查看长度信息位置 (0x2EE0)        f.seek(0x2EE0)  </span><br><span class="line">        length_bytes = f.read(4)  </span><br><span class="line">        encrypted_len = struct.unpack(&#x27;&lt;I&#x27;, length_bytes)[0]  </span><br><span class="line">        print(f&quot;[*] 0x2EE0处的长度值: 0x&#123;encrypted_len:X&#125; (&#123;encrypted_len&#125;)&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 查看加密数据开始位置 (0x1420)        f.seek(0x1420)  </span><br><span class="line">        encrypted_start = f.read(32)  </span><br><span class="line">        print(f&quot;[*] 0x1420处的前32字节: &#123;encrypted_start.hex()&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 统计有多少0xAA  </span><br><span class="line">        aa_count = encrypted_start.count(0xAA)  </span><br><span class="line">        print(f&quot;[*] 前32字节中0xAA的数量: &#123;aa_count&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 尝试解密前4字节  </span><br><span class="line">        for key in [0xAA, 0x55, 0xFF]:  </span><br><span class="line">            decrypted = bytes([b ^ key for b in encrypted_start[:4]])  </span><br><span class="line">            print(f&quot;[*] 密钥 0x&#123;key:02X&#125; 解密前4字节: &#123;decrypted.hex()&#125; = &#123;decrypted&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"># 运行  </span><br><span class="line">if __name__ == &quot;__main__&quot;:  </span><br><span class="line">    input_file = &quot;wrapper.so&quot;  </span><br><span class="line">    output_file = &quot;real_decrypted.so&quot;  </span><br><span class="line">  </span><br><span class="line">    print(&quot;=&quot; * 60)  </span><br><span class="line">    print(&quot;步骤1: 验证文件结构&quot;)  </span><br><span class="line">    print(&quot;=&quot; * 60)  </span><br><span class="line">    verify_extraction(input_file)  </span><br><span class="line">  </span><br><span class="line">    print(&quot;\n&quot; + &quot;=&quot; * 60)  </span><br><span class="line">    print(&quot;步骤2: 提取并解密SO文件&quot;)  </span><br><span class="line">    print(&quot;=&quot; * 60)  </span><br><span class="line">  </span><br><span class="line">    if extract_encrypted_so(input_file, output_file):  </span><br><span class="line">        print(&quot;\n[+] 提取完成！&quot;)  </span><br><span class="line">  </span><br><span class="line">        # 验证解密文件  </span><br><span class="line">        try:  </span><br><span class="line">            with open(output_file, &#x27;rb&#x27;) as f:  </span><br><span class="line">                header = f.read(64)  </span><br><span class="line">                print(f&quot;\n[*] 解密文件头64字节:&quot;)  </span><br><span class="line">                for i in range(0, 64, 16):  </span><br><span class="line">                    hex_str = &#x27; &#x27;.join(f&#x27;&#123;b:02X&#125;&#x27; for b in header[i:i + 16])  </span><br><span class="line">                    ascii_str = &#x27;&#x27;.join(chr(b) if 32 &lt;= b &lt; 127 else &#x27;.&#x27; for b in header[i:i + 16])  </span><br><span class="line">                    print(f&quot;  &#123;i:02X&#125;: &#123;hex_str&#125;  &#123;ascii_str&#125;&quot;)  </span><br><span class="line">        except:  </span><br><span class="line">            pass  </span><br><span class="line">    else:  </span><br><span class="line">        print(&quot;\n[!] 提取失败&quot;)</span><br></pre></td></tr></table></figure>
<p>将提取出来的进行，反编译，发现是RC4加密，没有魔改，现在还差密文就可以解出了，然后又去jadx中res中的raw找密文，用cyberchef解出第二部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  const char *v10; // [xsp+448h] [xbp-128h]</span><br><span class="line">  const char *v11; // [xsp+550h] [xbp-20h]</span><br><span class="line">  __int64 v12; // [xsp+558h] [xbp-18h]</span><br><span class="line">  __int64 v13; // [xsp+560h] [xbp-10h]</span><br><span class="line">  __int64 v14; // [xsp+568h] [xbp-8h]</span><br><span class="line"></span><br><span class="line">  v14 = a1;</span><br><span class="line">  v13 = a2;</span><br><span class="line">  v12 = a3;</span><br><span class="line">  v11 = &quot;mysecret&quot;;</span><br><span class="line">  v10 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0LL);</span><br><span class="line">  v9 = strlen(v10);</span><br><span class="line">  if ( v9 &gt;= 8 )</span><br><span class="line">    v4 = 8;</span><br><span class="line">  else</span><br><span class="line">    v4 = v9;</span><br><span class="line">  v8 = v4;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  strlen(v11);</span><br><span class="line">  rc4_init();</span><br><span class="line">  rc4_crypt();</span><br><span class="line">  memset(v6, 0, sizeof(v6));</span><br><span class="line">  for ( i = 0; i &lt; v9; ++i )</span><br><span class="line">    sprintf(&amp;v6[2 * i], &quot;%02X&quot;, *((unsigned __int8 *)&amp;v7 + i));</span><br><span class="line">  (*(void (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v14 + 1360LL))(v14, v12, v10);</span><br><span class="line">  return (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v14 + 1336LL))(v14, v6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/QMQ.github.io/images/geek/3.png"><br>在找密文的时候，在看到了function1，发现是des的加密，用cyberchef解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public abstract class function1 &#123;</span><br><span class="line">  </span><br><span class="line">    public static String function1(String input1) throws BadPaddingException, NoSuchPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">  </span><br><span class="line">            byte[] data = input1.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">  </span><br><span class="line">            int len = data.length;</span><br><span class="line">  </span><br><span class="line">            int padLen = 8 - (len % 8);</span><br><span class="line">  </span><br><span class="line">            byte[] padded = new byte[len + padLen];</span><br><span class="line">  </span><br><span class="line">            System.arraycopy(data, 0, padded, 0, len);</span><br><span class="line">  </span><br><span class="line">            SecretKeySpec keySpec = new SecretKeySpec(&quot;12345678&quot;.getBytes(&quot;UTF-8&quot;), &quot;DES&quot;);</span><br><span class="line">  </span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;DES/ECB/NoPadding&quot;);</span><br><span class="line">  </span><br><span class="line">            cipher.init(1, keySpec);</span><br><span class="line">  </span><br><span class="line">            byte[] encrypted = cipher.doFinal(padded);</span><br><span class="line">  </span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">  </span><br><span class="line">            for (byte b : encrypted) &#123;</span><br><span class="line">  </span><br><span class="line">                sb.append(String.format(&quot;%02X&quot;, Byte.valueOf(b)));</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            return sb.toString();</span><br><span class="line">  </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">  </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">  </span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/QMQ.github.io/images/geek/2.png"><br>然后又反编译function3，发现是des加密</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl Java_com_example_syc_function3_function3(int a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [esp+1Ch] [ebp-5Ch]</span><br><span class="line">  int v5; // [esp+20h] [ebp-58h]</span><br><span class="line">  _WORD v6[8]; // [esp+47h] [ebp-31h] BYREF</span><br><span class="line">  _BYTE v7[8]; // [esp+58h] [ebp-20h] BYREF</span><br><span class="line">  _BYTE s[8]; // [esp+60h] [ebp-18h] BYREF</span><br><span class="line">  unsigned int v9; // [esp+68h] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  v9 = __readgsdword(0x14u);</span><br><span class="line">  v5 = (*(*a1 + 676))(a1, a3, 0);</span><br><span class="line">  memset(s, 0, sizeof(s));</span><br><span class="line">  __strncpy_chk(s, v5, 8, 8);</span><br><span class="line">  (*(*a1 + 680))(a1, a3, v5);</span><br><span class="line">  memset(v7, 0, sizeof(v7));</span><br><span class="line">  des_encrypt(&amp;unk_128C, s, v7);</span><br><span class="line">  memset(v6, 0, 0x11u);</span><br><span class="line">  for ( i = 0; i &lt; 8; ++i )</span><br><span class="line">    sub_22C0(&amp;v6[i], -1, &quot;%02X&quot;, v7[i]);</span><br><span class="line">  return (*(*a1 + 668))(a1, v6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>魔改了很多地方，循环左移是在字节数组上实现，对s盒奇偶的不同处理，奇数不移位，偶数左移4位，子密钥的生成重叠内存布局（做的时候根本没有注意到，当时实在做不出了，去翻wp看到的）,标准的是将C和D完全独立存储，而这个是C和D有1字节重叠。还有一个重要的地方是s盒少了一个，要自己再弄出来，这里当时看的是一个师傅（当时做的时候，还想出题人这次这么好心，居然没有魔改s盒）<br>exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">KEY = bytes([0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1])</span><br><span class="line">CIPHERTEXT = bytes([0xAE, 0xBC, 0xDE, 0x9B, 0x24, 0x02, 0x9C, 0xA7])</span><br><span class="line"></span><br><span class="line">PC1 = [57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4]</span><br><span class="line">SHIFTS = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]</span><br><span class="line">PC2 = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32]</span><br><span class="line">E = [32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,22,23,24,25,24,25,26,27,28,29,28,29,30,31,32,1]</span><br><span class="line"></span><br><span class="line">SBOX = [</span><br><span class="line">    [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],</span><br><span class="line">    [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9],</span><br><span class="line">    [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12],</span><br><span class="line">    [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14],</span><br><span class="line">    [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3],</span><br><span class="line">    [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13],</span><br><span class="line">    [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,10,15,6,8,0,5,9,14,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12],</span><br><span class="line">    [0]*64</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">P = [16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25]</span><br><span class="line">IP = [58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7]</span><br><span class="line">FP = [40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25]</span><br><span class="line"></span><br><span class="line">def bytes_to_bits(data):</span><br><span class="line">    return [(byte &gt;&gt; (7-i)) &amp; 1 for byte in data for i in range(8)]</span><br><span class="line"></span><br><span class="line">def bits_to_bytes(bits):</span><br><span class="line">    return bytes([sum(bits[i*8+j] &lt;&lt; (7-j) for j in range(8)) for i in range(len(bits)//8)])</span><br><span class="line"></span><br><span class="line">def permute(bits, table):</span><br><span class="line">    return [bits[i-1] for i in table]</span><br><span class="line"></span><br><span class="line">def xor_bits(a, b):</span><br><span class="line">    return [x ^ y for x, y in zip(a, b)]</span><br><span class="line"></span><br><span class="line">def left_shift_32bit(a_bytes, n):</span><br><span class="line">    a = list(a_bytes)</span><br><span class="line">    v4 = a[0] &gt;&gt; (8 - n)</span><br><span class="line">    for i in range(3):</span><br><span class="line">        a[i] = ((a[i+1] &gt;&gt; (8 - n)) | (a[i] &lt;&lt; n)) &amp; 0xFF</span><br><span class="line">    a[3] = (v4 | (a[3] &lt;&lt; n)) &amp; 0xFF</span><br><span class="line">    return bytes(a)</span><br><span class="line"></span><br><span class="line">def generate_subkeys_modified(key_bytes):</span><br><span class="line">    key_bits = bytes_to_bits(key_bytes)</span><br><span class="line">    pc1_bits = permute(key_bits, PC1)</span><br><span class="line">    s_bytes = bits_to_bytes(pc1_bits)</span><br><span class="line"></span><br><span class="line">    C = s_bytes[0:4]</span><br><span class="line">    D = s_bytes[3:7]</span><br><span class="line"></span><br><span class="line">    subkeys = []</span><br><span class="line">    for i in range(16):</span><br><span class="line">        C = left_shift_32bit(C, SHIFTS[i])</span><br><span class="line">        D = left_shift_32bit(D, SHIFTS[i])</span><br><span class="line"></span><br><span class="line">        cd_bytes = C[0:3] + D[0:4]</span><br><span class="line">        cd_bits = bytes_to_bits(cd_bytes)</span><br><span class="line"></span><br><span class="line">        subkey = permute(cd_bits, PC2)</span><br><span class="line">        subkeys.append(subkey)</span><br><span class="line"></span><br><span class="line">    return subkeys</span><br><span class="line"></span><br><span class="line">def s_box_modified(bits48):</span><br><span class="line">    result_bytes = [0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">    for j in range(8):</span><br><span class="line">        block = bits48[j*6:(j+1)*6]</span><br><span class="line">        row = (block[0] &lt;&lt; 1) | block[5]</span><br><span class="line">        col = (block[1] &lt;&lt; 3) | (block[2] &lt;&lt; 2) | (block[3] &lt;&lt; 1) | block[4]</span><br><span class="line">        val = SBOX[j][row * 16 + col]</span><br><span class="line"></span><br><span class="line">        if j % 2 == 0:</span><br><span class="line">            v3 = 16 * val</span><br><span class="line">        else:</span><br><span class="line">            v3 = val</span><br><span class="line"></span><br><span class="line">        result_bytes[j // 2] |= v3</span><br><span class="line"></span><br><span class="line">    return bytes_to_bits(bytes(result_bytes))</span><br><span class="line"></span><br><span class="line">def feistel(R, subkey):</span><br><span class="line">    expanded = permute(R, E)</span><br><span class="line">    xored = xor_bits(expanded, subkey)</span><br><span class="line">    substituted = s_box_modified(xored)</span><br><span class="line">    return permute(substituted, P)</span><br><span class="line"></span><br><span class="line">def des_decrypt(ciphertext, key):</span><br><span class="line">    cipher_bits = bytes_to_bits(ciphertext)</span><br><span class="line">    key_bits = bytes_to_bits(key)</span><br><span class="line"></span><br><span class="line">    subkeys = generate_subkeys_modified(key)</span><br><span class="line"></span><br><span class="line">    ip_result = permute(cipher_bits, IP)</span><br><span class="line">    L = ip_result[:32]</span><br><span class="line">    R = ip_result[32:]</span><br><span class="line"></span><br><span class="line">    for i in range(16):</span><br><span class="line">        temp = R[:]</span><br><span class="line">        R = xor_bits(L, feistel(R, subkeys[15 - i]))</span><br><span class="line">        L = temp</span><br><span class="line"></span><br><span class="line">    combined = R + L</span><br><span class="line">    result = permute(combined, FP)</span><br><span class="line"></span><br><span class="line">    return bits_to_bytes(result)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    plaintext = des_decrypt(CIPHERTEXT, KEY)</span><br><span class="line">    print(f&quot;明文 (hex): &#123;plaintext.hex().upper()&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        plain_str = plaintext.decode(&#x27;ascii&#x27;)</span><br><span class="line">        print(f&quot;明文 (ascii): &#123;plain_str&#125;&quot;)</span><br><span class="line">        print(f&quot;\ninput3 = \&quot;&#123;plain_str&#125;\&quot;&quot;)</span><br><span class="line">    except:</span><br><span class="line">        print(f&quot;明文 (raw): &#123;plaintext&#125;&quot;)</span><br><span class="line">        print(f&quot;\ninput3 = &#123;plaintext&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>flag：Th1s_1s_Th3_R3@lly_F1ag!</p>
<h6 id="14-her"><a href="#14-her" class="headerlink" title="14.her"></a>14.her</h6><p>反汇编后很容易知道sub_E711B3是加密函数，看到了BUG发现点不开，看汇编发现上面有三个函数，把他们给ai，ai说是SEH（结构化异常处理），简单来说就是让程序在发生异常时能够进行处理，而不是直接崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">loc_E71DBD:                             ; CODE XREF: sub_E71D30+82↑j</span><br><span class="line">.text:00E71DBD                 mov     eax, [ebp+var_20]</span><br><span class="line">.text:00E71DC0                 cmp     eax, [ebp+var_8]</span><br><span class="line">.text:00E71DC3                 jnb     short loc_E71E3E</span><br><span class="line">.text:00E71DC5                 mov     eax, [ebp+var_20]</span><br><span class="line">.text:00E71DC8                 mov     dword_E7B1DC, eax</span><br><span class="line">.text:00E71DCD                 push    offset sub_E71181</span><br><span class="line">.text:00E71DD2                 push    large dword ptr fs:0</span><br><span class="line">.text:00E71DD9                 mov     large fs:0, esp</span><br><span class="line">.text:00E71DE0                 push    offset sub_E71186</span><br><span class="line">.text:00E71DE5                 push    large dword ptr fs:0</span><br><span class="line">.text:00E71DEC                 mov     large fs:0, esp</span><br><span class="line">.text:00E71DF3                 push    offset sub_E71091</span><br><span class="line">.text:00E71DF8                 push    large dword ptr fs:0</span><br><span class="line">.text:00E71DFF                 mov     large fs:0, esp</span><br><span class="line">.text:00E71E06                 ud2</span><br></pre></td></tr></table></figure>
<p>对SEH的不熟悉，就是加密以为是 sub_E71181-&gt;sub_E71186<br>-&gt;sub_E71091，实际上是SEH链生成的过程，实际上主加密是<br>翻过来的，同时中间还有小的调用，最终的加密是sub_E71181-&gt;sub_E71186<br>-&gt;sub_E71091-&gt;sub_E71186<br>-&gt;sub_E71091-&gt;sub_E71091,而且每次在每个异常处理后都要异或 0x1A373，当时做了半天发现是把它给漏了，还是看了官方wp，才知道的。<br>exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">def encrypt_char(c, i, cnt):  </span><br><span class="line">    jm = ord(c)  </span><br><span class="line">  </span><br><span class="line">    # enc1  </span><br><span class="line">    cnt += 1  </span><br><span class="line">    byte = (cnt ^ jm ^ 0xAA) &amp; 0xFF  </span><br><span class="line">    cnt ^= 0x1A373  </span><br><span class="line">  </span><br><span class="line">    # enc2 (第一次)  </span><br><span class="line">    cnt += 1  </span><br><span class="line">    byte = (byte + (cnt % 0x100 + i * i)) &amp; 0xFF  </span><br><span class="line">    cnt ^= 0x1A373  </span><br><span class="line">  </span><br><span class="line">    # enc3 (第一次)  </span><br><span class="line">    cnt += 1  </span><br><span class="line">    cnt ^= 0x1A373  </span><br><span class="line">    enc = ((byte &gt;&gt; 5) | (byte &lt;&lt; 3)) &amp; 0xFF  </span><br><span class="line">  </span><br><span class="line">    # enc2 (第二次)  </span><br><span class="line">    cnt += 1  </span><br><span class="line">    byte = (byte + (cnt % 0x100 + i * i)) &amp; 0xFF  </span><br><span class="line">    cnt ^= 0x1A373  </span><br><span class="line">  </span><br><span class="line">    # enc3 (第二次)  </span><br><span class="line">    cnt += 1  </span><br><span class="line">    cnt ^= 0x1A373  </span><br><span class="line">    enc = ((byte &gt;&gt; 5) | (byte &lt;&lt; 3)) &amp; 0xFF  </span><br><span class="line">  </span><br><span class="line">    # enc3 (第三次)  </span><br><span class="line">    cnt += 1  </span><br><span class="line">    cnt ^= 0x1A373  </span><br><span class="line">    enc = ((byte &gt;&gt; 5) | (byte &lt;&lt; 3)) &amp; 0xFF  </span><br><span class="line">  </span><br><span class="line">    return enc, cnt  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"># 测试  </span><br><span class="line">enc_data = bytes.fromhex(&#x27;2D4F693D5F01BD9FA46D89AE2AEAD19C716DE11E387E8C0ACE6BE0F736729900&#x27;)  </span><br><span class="line">enc_data = enc_data[:31]  </span><br><span class="line">  </span><br><span class="line">flag = []  </span><br><span class="line">cnt = 0x1A373  </span><br><span class="line">for i in range(31):  </span><br><span class="line">    target = enc_data[i]  </span><br><span class="line">    found = False  </span><br><span class="line">    for c in range(32, 127):  </span><br><span class="line">        enc, new_cnt = encrypt_char(chr(c), i, cnt)  </span><br><span class="line">        if enc == target:  </span><br><span class="line">            flag.append(chr(c))  </span><br><span class="line">            cnt = new_cnt  </span><br><span class="line">            found = True  </span><br><span class="line">            break    if not found:  </span><br><span class="line">        flag.append(&#x27;?&#x27;)  </span><br><span class="line">  </span><br><span class="line">print(&#x27;&#x27;.join(flag))</span><br></pre></td></tr></table></figure>
<p>SYC{M@y_bE_m3et_HeR_1s_A_Err0R}</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/QMQ.github.io/2025/12/21/PE%E6%96%87%E4%BB%B6/" rel="next" title="PE文件解析">
      PE文件解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-QYQS%E3%81%AE%E5%A5%87%E5%A6%99%E5%86%92%E9%99%A9"><span class="nav-number">1.</span> <span class="nav-text">1.QYQSの奇妙冒险</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-ez-pyyy"><span class="nav-number">2.</span> <span class="nav-text">2.ez_pyyy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-only-flower"><span class="nav-number">3.</span> <span class="nav-text">3.only_flower</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-ezSMC"><span class="nav-number">4.</span> <span class="nav-text">4.ezSMC</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-encode"><span class="nav-number">5.</span> <span class="nav-text">5.encode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-Gensh1n"><span class="nav-number">6.</span> <span class="nav-text">6.Gensh1n</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-ez-rust"><span class="nav-number">7.</span> <span class="nav-text">7.ez_rust</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8-QYQS%E3%81%AE%E5%A5%87%E5%A6%99%E5%86%92%E9%99%A92"><span class="nav-number">8.</span> <span class="nav-text">8.QYQSの奇妙冒险2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9-ez-vm"><span class="nav-number">9.</span> <span class="nav-text">9.ez_vm</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-GeekBinder"><span class="nav-number">10.</span> <span class="nav-text">10.GeekBinder</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-Mission-Ghost-Signal"><span class="nav-number">11.</span> <span class="nav-text">11.Mission Ghost Signal</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#12-reReverse"><span class="nav-number">12.</span> <span class="nav-text">12.reReverse</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#13-ez-android"><span class="nav-number">13.</span> <span class="nav-text">13.ez_android</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#14-her"><span class="nav-number">14.</span> <span class="nav-text">14.her</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QVQ</p>
  <div class="site-description" itemprop="description">睡觉中......</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/QMQ.github.io/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/QMQ.github.io/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QVQ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/QMQ.github.io/lib/anime.min.js"></script>
  <script src="/QMQ.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/QMQ.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/QMQ.github.io/js/utils.js"></script>

<script src="/QMQ.github.io/js/motion.js"></script>


<script src="/QMQ.github.io/js/schemes/muse.js"></script>


<script src="/QMQ.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
